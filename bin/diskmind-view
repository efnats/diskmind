#!/usr/bin/env python3
"""
diskmind - Web Server
Serves live reports from SQLite database.
"""

import argparse
import json
import os
import sqlite3
import subprocess
import sys
import threading
from datetime import datetime
from http.server import HTTPServer, BaseHTTPRequestHandler
from pathlib import Path
from urllib.parse import urlparse, parse_qs

# Optional: yaml for config
try:
    import yaml
    HAS_YAML = True
except ImportError:
    HAS_YAML = False

# ---------------------------------------------------------------------------
# Database Functions
# ---------------------------------------------------------------------------

def get_db_connection(db_path: str) -> sqlite3.Connection:
    """Get database connection with row factory."""
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn


# Delta preset mappings (preset name -> days)
DELTA_PRESETS = {
    '1h': 1/24,
    '24h': 1,
    '7d': 7,
    '30d': 30,
    '90d': 90,
    'all': 36500,
}


def get_current_readings(db_path: str) -> list[dict]:
    """Get most recent reading for each disk."""
    conn = get_db_connection(db_path)
    cursor = conn.cursor()
    
    # Get latest reading per disk_id
    cursor.execute('''
        SELECT * FROM readings
        WHERE (disk_id, timestamp) IN (
            SELECT disk_id, MAX(timestamp) FROM readings GROUP BY disk_id
        )
        ORDER BY host, device
    ''')
    
    results = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return results


def get_trends(db_path: str, days: int = 30) -> dict:
    """Get sector trends for each disk (reallocated sectors change over time)."""
    conn = get_db_connection(db_path)
    cursor = conn.cursor()
    
    # Get all readings from last N days
    cursor.execute('''
        SELECT disk_id, smart_attributes, timestamp
        FROM readings
        WHERE timestamp > datetime('now', ?)
        ORDER BY disk_id, timestamp
    ''', (f'-{days} days',))
    
    # Group by disk_id and extract reallocated sectors
    by_disk = {}
    for row in cursor.fetchall():
        disk_id = row['disk_id']
        if disk_id not in by_disk:
            by_disk[disk_id] = []
        
        attrs = row['smart_attributes']
        if isinstance(attrs, str):
            try:
                attrs = json.loads(attrs)
            except:
                attrs = {}
        
        realloc = int(attrs.get('Reallocated_Sector_Ct', 0) or 0)
        by_disk[disk_id].append(realloc)
    
    # Calculate trends
    trends = {}
    for disk_id, values in by_disk.items():
        if len(values) >= 2:
            delta = values[-1] - values[0]
            if delta != 0:
                trends[disk_id] = {
                    'old': values[0],
                    'new': values[-1],
                    'delta': delta
                }
    
    conn.close()
    return trends


def get_disk_history(db_path: str, disk_id: str = None, days: int = 30) -> dict:
    """Get historical attribute values for sparkline rendering.
    Returns {disk_id: {attr_name: [{timestamp, value}, ...], ...}, ...}
    """
    conn = get_db_connection(db_path)
    cursor = conn.cursor()

    if disk_id:
        cursor.execute('''
            SELECT disk_id, timestamp, smart_attributes, type
            FROM readings
            WHERE disk_id = ? AND timestamp > datetime('now', ?)
            ORDER BY timestamp
        ''', (disk_id, f'-{days} days'))
    else:
        cursor.execute('''
            SELECT disk_id, timestamp, smart_attributes, type
            FROM readings
            WHERE timestamp > datetime('now', ?)
            ORDER BY disk_id, timestamp
        ''', (f'-{days} days',))

    history = {}
    for row in cursor.fetchall():
        did = row['disk_id']
        if did not in history:
            history[did] = {'_type': row['type'], '_timestamps': []}

        ts = row['timestamp']
        history[did]['_timestamps'].append(ts)

        attrs = row['smart_attributes']
        if isinstance(attrs, str):
            try:
                attrs = json.loads(attrs)
            except:
                attrs = {}

        for attr_name, value in attrs.items():
            if attr_name not in history[did]:
                history[did][attr_name] = []
            try:
                history[did][attr_name].append({'t': ts, 'v': float(value)})
            except (ValueError, TypeError):
                pass

    conn.close()

    # Compute per-attribute summary: current, delta, points array
    result = {}
    for did, attr_data in history.items():
        disk_type = attr_data.pop('_type', None)
        timestamps = attr_data.pop('_timestamps', [])
        result[did] = {
            '_type': disk_type,
            '_readings': len(set(timestamps)),
            '_first': timestamps[0] if timestamps else None,
            '_last': timestamps[-1] if timestamps else None,
        }
        for attr_name, points in attr_data.items():
            if len(points) < 1:
                continue
            values = [p['v'] for p in points]
            result[did][attr_name] = {
                'points': values,
                'current': values[-1],
                'delta': values[-1] - values[0] if len(values) >= 2 else 0,
                'min': min(values),
                'max': max(values),
            }

    return result


def get_hosts(db_path: str) -> list[str]:
    """Get list of all hosts."""
    conn = get_db_connection(db_path)
    cursor = conn.cursor()
    cursor.execute('SELECT DISTINCT host FROM readings ORDER BY host')
    hosts = [row['host'] for row in cursor.fetchall()]
    conn.close()
    return hosts


def get_host_status(db_path: str) -> dict:
    """Get host status from host_status table."""
    conn = get_db_connection(db_path)
    cursor = conn.cursor()
    
    # Check if table exists
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='host_status'")
    if not cursor.fetchone():
        conn.close()
        return {}
    
    cursor.execute('''
        SELECT host, status, message, disk_count, last_attempt, last_success
        FROM host_status
    ''')
    result = {}
    for row in cursor.fetchall():
        result[row['host']] = {
            'status': row['status'],
            'message': row['message'],
            'disk_count': row['disk_count'],
            'last_attempt': row['last_attempt'],
            'last_success': row['last_success'],
        }
    conn.close()
    return result


def get_host_stats(db_path: str) -> dict:
    """Get per-host last scan time and disk count."""
    conn = get_db_connection(db_path)
    cursor = conn.cursor()
    cursor.execute('''
        SELECT host,
               MAX(timestamp) as last_seen,
               COUNT(DISTINCT serial) as disk_count
        FROM readings
        GROUP BY host
    ''')
    stats = {}
    for row in cursor.fetchall():
        stats[row['host']] = {
            'last_seen': row['last_seen'],
            'disk_count': row['disk_count'],
        }
    conn.close()
    return stats


def get_stats(readings: list[dict]) -> dict:
    """Calculate summary statistics."""
    total = len(readings)
    critical = 0
    warning = 0
    healthy = 0
    total_capacity = 0
    
    for r in readings:
        total_capacity += r.get('capacity_bytes') or 0
        
        status = classify_disk(r)
        if status == 'critical':
            critical += 1
        elif status == 'warning':
            warning += 1
        else:
            healthy += 1
    
    return {
        'total': total,
        'critical': critical,
        'warning': warning,
        'healthy': healthy,
        'total_capacity_tb': round(total_capacity / 1e12, 1) if total_capacity else 0,
    }


# ---------------------------------------------------------------------------
# Threshold-based Health Classification
# ---------------------------------------------------------------------------

DEFAULT_PRESET = 'backblaze'

def _find_thresholds_file() -> Path | None:
    """Locate config/thresholds.json."""
    base_dir = Path(__file__).parent.parent
    candidates = [
        base_dir / 'config' / 'thresholds.json',
        base_dir / 'lib' / 'thresholds.json',
        base_dir / 'thresholds.json',
        Path(__file__).parent / 'thresholds.json',
    ]
    for path in candidates:
        if path.exists():
            return path
    return None


def _parse_simple_yaml(text: str) -> dict:
    """Parse simple YAML (flat keys, string values, simple lists). No PyYAML needed."""
    result = {}
    current_key = None
    current_list = None
    for raw_line in text.split('\n'):
        stripped = raw_line.strip()
        if not stripped or stripped.startswith('#'):
            continue
        indent = len(raw_line) - len(raw_line.lstrip())
        if indent > 0 and current_key and stripped.startswith('- '):
            val = stripped[2:].strip()
            if current_list is None:
                current_list = []
                result[current_key] = current_list
            current_list.append(val)
        elif indent > 0 and current_key and ':' in stripped:
            k, _, v = stripped.partition(':')
            v = v.strip()
            if not isinstance(result.get(current_key), dict):
                result[current_key] = {}
            if v:
                try:
                    result[current_key][k.strip()] = int(v)
                except ValueError:
                    result[current_key][k.strip()] = v
        elif ':' in stripped and indent == 0:
            k, _, v = stripped.partition(':')
            k = k.strip()
            v = v.strip()
            current_key = k
            current_list = None
            if v:
                try:
                    result[k] = int(v)
                except ValueError:
                    result[k] = v
    return result


def _get_config_path() -> Path:
    """Get path to config/config.yaml."""
    base_dir = Path(__file__).parent.parent
    return base_dir / 'config' / 'config.yaml'


def load_config() -> dict:
    """Load user config from config/config.yaml."""
    config_path = _get_config_path()
    if config_path.exists():
        try:
            with open(config_path) as f:
                return _parse_simple_yaml(f.read())
        except IOError:
            pass
    return {}


def save_config_value(key: str, value: str):
    """Update a single top-level key in config/config.yaml, preserving comments."""
    config_path = _get_config_path()
    config_path.parent.mkdir(parents=True, exist_ok=True)
    
    if config_path.exists():
        lines = config_path.read_text().splitlines()
    else:
        lines = []
    
    # Find and replace existing key, or append
    found = False
    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith('#'):
            continue
        if ':' in stripped:
            k, _, _ = stripped.partition(':')
            if k.strip() == key:
                lines[i] = f'{key}: {value}'
                found = True
                break
    if not found:
        lines.append(f'{key}: {value}')
    
    config_path.write_text('\n'.join(lines) + '\n')


def save_config_list(key: str, items: list):
    """Update a top-level list key in config/config.yaml, preserving comments."""
    config_path = _get_config_path()
    config_path.parent.mkdir(parents=True, exist_ok=True)
    
    if config_path.exists():
        lines = config_path.read_text().splitlines()
    else:
        lines = []
    
    # Find key, remove old list items, insert new ones
    key_idx = None
    remove_end = None
    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith('#'):
            continue
        if key_idx is not None:
            # We're inside the list — consume indented lines
            indent = len(line) - len(line.lstrip())
            if indent > 0 and (stripped.startswith('- ') or stripped.startswith('#')):
                remove_end = i + 1
            else:
                break
        elif ':' in stripped:
            k, _, _ = stripped.partition(':')
            if k.strip() == key:
                key_idx = i
                remove_end = i + 1
    
    new_lines = [f'  - {item}' for item in items]
    
    if key_idx is not None:
        lines[key_idx:remove_end] = [f'{key}:'] + new_lines
    else:
        lines.append(f'{key}:')
        lines.extend(new_lines)
    
    config_path.write_text('\n'.join(lines) + '\n')


def save_config_subkey(section: str, key: str, value):
    """Update a nested key (e.g. ssh.user) in config/config.yaml."""
    config_path = _get_config_path()
    config_path.parent.mkdir(parents=True, exist_ok=True)
    
    if config_path.exists():
        lines = config_path.read_text().splitlines()
    else:
        lines = []
    
    section_idx = None
    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith('#'):
            continue
        if section_idx is not None:
            indent = len(line) - len(line.lstrip())
            if indent > 0 and ':' in stripped:
                k, _, _ = stripped.partition(':')
                if k.strip() == key:
                    lines[i] = f'  {key}: {value}'
                    config_path.write_text('\n'.join(lines) + '\n')
                    return
            elif indent == 0 and stripped:
                # Past the section, insert before this line
                lines.insert(i, f'  {key}: {value}')
                config_path.write_text('\n'.join(lines) + '\n')
                return
        elif ':' in stripped:
            k, _, _ = stripped.partition(':')
            if k.strip() == section:
                section_idx = i
    
    # Key not found; append to section or create section
    if section_idx is not None:
        lines.append(f'  {key}: {value}')
    else:
        lines.extend([f'{section}:', f'  {key}: {value}'])
    config_path.write_text('\n'.join(lines) + '\n')


def load_all_presets() -> dict:
    """Load all presets from thresholds.json."""
    path = _find_thresholds_file()
    if path:
        try:
            with open(path) as f:
                data = json.load(f)
            return data.get('presets', {})
        except (json.JSONDecodeError, IOError):
            pass
    return {}


def load_thresholds() -> dict:
    """Load active thresholds: config preset selection → resolve from presets or custom."""
    config = load_config()
    preset_name = config.get('threshold_preset', DEFAULT_PRESET)
    
    # If custom preset, load from config
    if preset_name == 'custom':
        custom = config.get('custom_thresholds')
        if custom:
            return {
                'ata': custom.get('ata', {}),
                'nvme': custom.get('nvme', {}),
            }
    
    presets = load_all_presets()
    
    # If preset exists, return its ata/nvme rules
    if preset_name in presets:
        preset = presets[preset_name]
        return {
            'ata': preset.get('ata', {}),
            'nvme': preset.get('nvme', {}),
        }
    
    # Fallback: try 'backblaze', then first available preset
    if DEFAULT_PRESET in presets:
        preset = presets[DEFAULT_PRESET]
        return {
            'ata': preset.get('ata', {}),
            'nvme': preset.get('nvme', {}),
        }
    
    if presets:
        first = next(iter(presets.values()))
        return {
            'ata': first.get('ata', {}),
            'nvme': first.get('nvme', {}),
        }
    
    return {}


def save_custom_thresholds(thresholds: dict):
    """Save custom thresholds to config.yaml."""
    config_path = get_config_path()
    try:
        with open(config_path, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        lines = []
    
    # Remove existing custom_thresholds section if present
    new_lines = []
    skip_until_unindent = False
    for line in lines:
        if line.startswith('custom_thresholds:'):
            skip_until_unindent = True
            continue
        if skip_until_unindent:
            if line.startswith(' ') or line.startswith('\t') or line.strip() == '':
                continue
            else:
                skip_until_unindent = False
        new_lines.append(line)
    
    # Add custom_thresholds as YAML
    import yaml
    custom_yaml = yaml.dump({'custom_thresholds': thresholds}, default_flow_style=False)
    new_lines.append('\n')
    new_lines.append(custom_yaml)
    
    with open(config_path, 'w') as f:
        f.writelines(new_lines)


# Cache thresholds at module level (invalidated on settings change)
_thresholds = None

def get_thresholds() -> dict:
    global _thresholds
    if _thresholds is None:
        _thresholds = load_thresholds()
    return _thresholds

def invalidate_threshold_cache():
    global _thresholds
    _thresholds = None


def check_threshold(attr_value, rule: dict) -> bool:
    """Check if an attribute value exceeds a threshold rule."""
    try:
        val = float(attr_value)
    except (ValueError, TypeError):
        return False
    
    op = rule.get('op', '>')
    threshold = rule.get('value', 0)
    
    if op == '>':
        return val > threshold
    elif op == '>=':
        return val >= threshold
    elif op == '<':
        return val < threshold
    elif op == '<=':
        return val <= threshold
    elif op == '==':
        return val == threshold
    return False


def classify_disk(r: dict, history: dict = None, delta_days: float = None) -> str:
    """Classify disk status based on visible issues (respecting delta filter)."""
    issues = get_disk_issues(r, history, delta_days)
    
    # Status is determined by the filtered issues
    for issue in issues:
        if issue['level'] == 'critical':
            return 'critical'
    for issue in issues:
        if issue['level'] == 'warning':
            return 'warning'
    
    return 'ok'


# Cumulative event counters - only show if delta > 0 in selected time range
# These are counters that accumulate over time; old values aren't necessarily concerning
CUMULATIVE_EVENT_ATTRS = {
    'Command_Timeout',
    'Reported_Uncorrect',
    'UDMA_CRC_Error_Count',
    'Unsafe_Shutdowns',
    'Error_Information_Log_Entries',
    'Power_Off_Retract_Count',
}

# Critical state attributes - always show regardless of delta
# These represent current state or irreversible damage
CRITICAL_STATE_ATTRS = {
    'Reallocated_Sector_Ct',
    'Current_Pending_Sector',
    'Offline_Uncorrectable',
    'Media_and_Data_Integrity_Errors',
    'Critical_Warning',
    'Percentage_Used',
    'Available_Spare',
}


def decode_seagate_value(attr_name: str, raw_value) -> int:
    """Decode Seagate composite 48-bit raw values.
    
    Seagate packs multiple counters into raw values:
    - Command_Timeout (#188): low 16 bits = actual timeout count
    - Raw_Read_Error_Rate (#1): high 16 bits = error count
    - Seek_Error_Rate (#7): high 16 bits = error count
    """
    try:
        raw = int(raw_value)
    except (ValueError, TypeError):
        return 0
    
    if raw <= 65535:  # Not a composite value
        return raw
    
    if attr_name == 'Command_Timeout':
        return raw & 0xFFFF
    elif attr_name in ('Raw_Read_Error_Rate', 'Seek_Error_Rate'):
        return (raw >> 32) & 0xFFFF
    
    return raw


def get_disk_issues(r: dict, history: dict = None, delta_days: float = None) -> list[dict]:
    """Get list of threshold violations for a disk, filtered by delta time range.
    
    Args:
        r: Disk reading dict
        history: History data for this disk (with deltas)
        delta_days: Time range in days (None or >= 36500 means all time)
    
    Returns:
        List of issues that should be shown based on:
        - Critical state attrs: always shown if threshold exceeded
        - Cumulative counters: only shown if delta > 0 in time range
    """
    attrs = r.get('smart_attributes', {})
    if isinstance(attrs, str):
        try:
            attrs = json.loads(attrs)
        except:
            attrs = {}
    
    thresholds = get_thresholds()
    disk_type = (r.get('type') or '').strip()
    is_nvme = disk_type == 'NVMe'
    
    if is_nvme:
        rules = thresholds.get('nvme', {})
    else:
        rules = thresholds.get('ata', {})
    
    issues = []
    all_time = delta_days is None or delta_days >= 36500
    
    # SMART self-test failure is always critical
    if r.get('smart_status') not in ('PASSED', 'N/A', None):
        issues.append({'level': 'critical', 'text': 'SMART Failed'})
    
    def should_show_attr(attr_name: str) -> bool:
        """Determine if an attribute's issue should be shown based on delta filter."""
        # All time mode - show everything
        if all_time:
            return True
        
        # Critical state attrs always shown
        if attr_name in CRITICAL_STATE_ATTRS:
            return True
        
        # Cumulative counters - only show if delta > 0
        if attr_name in CUMULATIVE_EVENT_ATTRS:
            if history and attr_name in history:
                attr_hist = history[attr_name]
                delta = attr_hist.get('delta', 0) if isinstance(attr_hist, dict) else 0
                return delta > 0
            # No history data - don't show (can't prove it's new)
            return False
        
        # Unknown attr type - show to be safe
        return True
    
    # Check critical thresholds
    for attr_name, rule in rules.get('critical', {}).items():
        if attr_name.startswith('_'):
            continue
        val = attrs.get(attr_name)
        if val is not None:
            check_val = decode_seagate_value(attr_name, val) if not is_nvme else val
            if check_threshold(check_val, rule):
                if should_show_attr(attr_name):
                    display = rule.get('display', attr_name)
                    issues.append({'level': 'critical', 'text': f'{check_val} {display}'})
    
    # Check warning thresholds (skip if already critical for same attribute)
    critical_attrs = set(rules.get('critical', {}).keys())
    for attr_name, rule in rules.get('warning', {}).items():
        if attr_name.startswith('_'):
            continue
        # Skip if already flagged as critical
        if attr_name in critical_attrs:
            val = attrs.get(attr_name)
            if val is not None:
                check_val = decode_seagate_value(attr_name, val) if not is_nvme else val
                if check_threshold(check_val, rules['critical'][attr_name]):
                    continue
        val = attrs.get(attr_name)
        if val is not None:
            check_val = decode_seagate_value(attr_name, val) if not is_nvme else val
            if check_threshold(check_val, rule):
                if should_show_attr(attr_name):
                    display = rule.get('display', attr_name)
                    issues.append({'level': 'warning', 'text': f'{check_val} {display}'})
    
    return issues


def generate_static_html(readings: list[dict], trends: dict, stats: dict, hosts: list[str]) -> str:
    """Generate static HTML report."""
    # Group by host
    by_host = {}
    for r in readings:
        host = r['host']
        if host not in by_host:
            by_host[host] = []
        by_host[host].append(r)
    
    # Build host sections
    host_sections = ''
    for host in sorted(by_host.keys()):
        disks = by_host[host]
        
        # Sort disks by type: NVMe -> SSD -> HDD -> Unknown
        type_order = {'NVMe': 0, 'SSD': 1, 'HDD': 2, 'Unknown': 3}
        disks.sort(key=lambda d: (type_order.get(d.get('type'), 3), d.get('device', '')))
        
        critical = sum(1 for d in disks if d['status'] == 'critical')
        warning = sum(1 for d in disks if d['status'] == 'warning')
        capacity_tb = sum(d.get('capacity_bytes') or 0 for d in disks) / 1e12
        
        badge_class = 'ok'
        badge_text = 'OK'
        if critical > 0:
            badge_class = 'critical'
            badge_text = f'{critical} critical'
        elif warning > 0:
            badge_class = 'warning'
            badge_text = f'{warning} warning'
        
        rows = ''
        for d in disks:
            type_class = (d.get('type') or '').lower()
            status_dot = 'ok' if d.get('smart_status') == 'PASSED' else 'fail'
            cap = d.get('capacity_bytes') or 0
            cap_fmt = f"{cap/1e12:.1f}TB" if cap >= 1e12 else f"{cap/1e9:.0f}GB"
            disk_id = d.get('disk_id', d.get('serial', ''))
            trend_html = '<span class="trend">▲</span>' if trends.get(disk_id, {}).get('delta', 0) > 0 else ''
            
            # Parse smart_attributes
            smart_attrs = d.get('smart_attributes', {})
            if isinstance(smart_attrs, str):
                try:
                    smart_attrs = json.loads(smart_attrs)
                except:
                    smart_attrs = {}
            
            # Get values from JSON
            hours = int(smart_attrs.get('Power_On_Hours', 0) or 0)
            hours_fmt = f"{hours/1000:.1f}k" if hours >= 1000 else str(hours)
            temp = smart_attrs.get('Temperature_Celsius') or smart_attrs.get('Airflow_Temperature_Cel') or '-'
            
            # Use threshold-based issue detection
            disk_issues = get_disk_issues(d)
            issues = ''
            for issue in disk_issues:
                issues += f'<span class="issue {issue["level"]}">{issue["text"]}</span>'
            
            # Build detail items from smart_attributes
            detail_items = f'<div class="detail-item"><span class="label">Serial</span><span class="value">{d["serial"]}</span></div>'
            if d.get('wwn'):
                detail_items += f'<div class="detail-item"><span class="label">WWN</span><span class="value">{d["wwn"]}</span></div>'
            
            if smart_attrs:
                for name, value in smart_attrs.items():
                    display_name = name.replace('_', ' ')
                    detail_items += f'<div class="detail-item"><span class="label">{display_name}</span><span class="value">{value}</span></div>'
            else:
                detail_items += '<div class="detail-item"><span class="label">No SMART data</span><span class="value">-</span></div>'
            
            # Add trend if available
            if trends.get(disk_id, {}).get('delta', 0) > 0:
                detail_items += f'<div class="detail-item"><span class="label">30d Trend</span><span class="value" style="color:var(--warning)">+{trends[disk_id]["delta"]} sectors</span></div>'
            
            # Use disk_id (escaped) for HTML element IDs
            eid = disk_id.replace('"', '').replace("'", '').replace(' ', '_')
            rows += f'''<tr class="disk-row {d['status']}" data-type="{d.get('type')}" data-status="{d['status']}" onclick="toggleDetail('{eid}')">
                <td><span class="device-name">{d['device']}</span><span class="type-badge {type_class}">{d.get('type') or '?'}</span></td>
                <td>{d.get('model') or '-'}</td>
                <td class="mono muted">{d['serial']}</td>
                <td>{cap_fmt}</td>
                <td class="mono">{hours_fmt}{trend_html}</td>
                <td>{temp}°</td>
                <td><span class="status-dot {status_dot}"></span>{d.get('smart_status') or 'N/A'}</td>
                <td>{issues or '-'}</td>
            </tr>
            <tr class="detail-row" id="detail-{eid}">
                <td colspan="9">
                    <div class="detail-grid">
                        {detail_items}
                    </div>
                </td>
            </tr>'''
        
        host_sections += f'''<div class="host-group" data-host="{host}">
            <div class="host-header" onclick="this.parentElement.classList.toggle('collapsed')">
                <div><span class="host-name">{host}</span><span class="host-badge {badge_class}">{badge_text}</span></div>
                <div class="host-stats">{len(disks)} drives · {capacity_tb:.1f} TB <span class="host-toggle">▼</span></div>
            </div>
            <div class="host-content">
                <table class="disk-table">
                    <thead><tr><th>Device</th><th>Model</th><th>Serial</th><th>Size</th><th>Hours</th><th>Temp</th><th>Status</th><th>Issues</th></tr></thead>
                    <tbody>{rows}</tbody>
                </table>
            </div>
        </div>'''
    
    # Host options for filter
    host_options = ''.join(f'<option value="{h}">{h}</option>' for h in hosts)
    
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
    
    return get_html_template().replace(
        '<div id="content"><div class="loading">Loading...</div></div>',
        f'<div id="content">{host_sections}</div>'
    ).replace(
        '<option value="">All Hosts</option>',
        f'<option value="">All Hosts</option>{host_options}'
    ).replace(
        '<span class="timestamp" id="lastUpdate">Loading...</span>',
        f'<span class="timestamp">{timestamp}</span>'
    ).replace(
        '<div class="stat-value" id="statCritical">-</div>',
        f'<div class="stat-value" id="statCritical">{stats["critical"]}</div>'
    ).replace(
        '<div class="stat-value" id="statWarning">-</div>',
        f'<div class="stat-value" id="statWarning">{stats["warning"]}</div>'
    ).replace(
        '<div class="stat-value" id="statHealthy">-</div>',
        f'<div class="stat-value" id="statHealthy">{stats["healthy"]}</div>'
    ).replace(
        '<div class="stat-value" id="statTotal">-</div>',
        f'<div class="stat-value" id="statTotal">{stats["total"]}</div>'
    ).replace(
        '<div class="stat-sub" id="statCapacity">-</div>',
        f'<div class="stat-sub" id="statCapacity">{stats["total_capacity_tb"]} TB</div>'
    ).replace(
        '<button class="btn primary" id="refreshBtn" onclick="refresh()">↻ Refresh</button>',
        ''
    ).replace(
        'loadData();',
        '// Static report - no auto-load'
    ).replace(
        "setInterval(loadData, 60000);",
        "// Static report - no auto-refresh"
    )


# ---------------------------------------------------------------------------
# HTML Template
# ---------------------------------------------------------------------------

def get_html_template() -> str:
    """Return the HTML template."""
    return '''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diskmind</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #f8fafc; --bg-card: #ffffff; --bg-hover: #f1f5f9;
            --text-primary: #0f172a; --text-secondary: #475569; --text-muted: #94a3b8;
            --border: #e2e8f0; --accent: #3b82f6;
            --success: #10b981; --warning: #f59e0b; --danger: #ef4444;
        }
        [data-theme="dark"] {
            --bg-primary: #0f172a; --bg-card: #1e293b; --bg-hover: #334155;
            --text-primary: #f1f5f9; --text-secondary: #cbd5e1; --text-muted: #64748b;
            --border: #334155;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Inter', sans-serif; background: var(--bg-primary); color: var(--text-primary); line-height: 1.5; }
        .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
        
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
        .header h1 { font-size: 22px; font-weight: 700; }
        .header-right { display: flex; align-items: center; gap: 12px; }
        .timestamp { font-size: 13px; color: var(--text-muted); }
        .btn { background: var(--bg-hover); border: 1px solid var(--border); border-radius: 6px; padding: 6px 12px; cursor: pointer; font-size: 13px; color: var(--text-secondary); transition: all 0.15s; }
        .btn:hover { background: var(--border); }
        .btn.primary { background: var(--accent); color: white; border-color: var(--accent); }
        .btn.primary:hover { opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px; }
        .stat { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 16px 20px; border-left: 4px solid var(--accent); cursor: pointer; transition: all 0.15s; }
        .stat:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .stat.active { box-shadow: 0 0 0 2px var(--accent); }
        .stat.critical { border-left-color: var(--danger); }
        .stat.warning { border-left-color: var(--warning); }
        .stat.healthy { border-left-color: var(--success); }
        .stat-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); }
        .stat-value { font-size: 28px; font-weight: 700; }
        .stat.critical .stat-value { color: var(--danger); }
        .stat.warning .stat-value { color: var(--warning); }
        .stat-sub { font-size: 12px; color: var(--text-muted); }
        
        .filters { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 12px 16px; margin-bottom: 24px; display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap; }
        .delta-range { display: flex; align-items: center; gap: 4px; }
        .delta-range .delta-label { font-size: 13px; color: var(--text-secondary); padding: 0 2px; }
        .delta-range input[type="number"] { width: 50px; padding: 6px 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px; text-align: center; }
        .delta-range select { padding: 6px 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px; }
        .filter-separator { width: 1px; height: 24px; background: var(--border); margin: 0 12px; align-self: flex-end; margin-bottom: 6px; }
        .filter-group { display: flex; align-items: center; gap: 4px; }
        .filter-group-labeled { display: flex; flex-direction: column; gap: 4px; }
        .filter-group-label { font-size: 10px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); }
        .info-icon { cursor: help; opacity: 0.6; font-size: 11px; position: relative; }
        .info-icon:hover { opacity: 1; }
        .info-icon:hover::after { content: attr(data-tip); position: absolute; left: 50%; transform: translateX(-50%); top: 18px; background: #1a1a2e; color: #e2e8f0; padding: 10px 14px; border-radius: 6px; font-size: 12px; font-weight: 400; text-transform: none; letter-spacing: normal; width: max-content; max-width: 260px; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.3); line-height: 1.5; }
        [data-theme="dark"] .info-icon:hover::after { background: #2a3a52; }
        .filter-group-controls { display: flex; align-items: center; gap: 6px; }
        .filter-group-controls > select, #deltaRange { padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px; }
        .filter-group-controls > input:not(.search-input) { padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px; width: 140px; }
        .filter-group-end { margin-left: auto; }
        .search-input { padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px; width: 140px; }
        .search-input:focus { outline: none; border-color: var(--accent); }
        
        /* Custom Dropdown */
        .custom-select { position: relative; min-width: 120px; }
        .custom-select-trigger { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px; cursor: pointer; transition: all 0.15s; user-select: none; }
        .custom-select-trigger:hover { border-color: var(--text-muted); }
        .custom-select.open .custom-select-trigger { border-color: var(--accent); }
        .custom-select-arrow { font-size: 10px; color: var(--text-muted); transition: transform 0.2s; }
        .custom-select.open .custom-select-arrow { transform: rotate(180deg); }
        .custom-select-options { position: absolute; top: calc(100% + 4px); left: 0; right: 0; background: var(--bg-card); border: 1px solid var(--border); border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; opacity: 0; visibility: hidden; transform: translateY(-8px); transition: all 0.15s ease; max-height: 240px; overflow-y: auto; }
        .custom-select.open .custom-select-options { opacity: 1; visibility: visible; transform: translateY(0); }
        .custom-select-option { padding: 8px 12px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: background 0.1s; }
        .custom-select-option:hover { background: var(--bg-hover); }
        .custom-select-option.selected { color: var(--accent); }
        .custom-select-option.selected::before { content: '✓'; font-size: 11px; }
        .custom-select-option:not(.selected)::before { content: ''; width: 11px; }
        .custom-select-option:first-child { border-radius: 5px 5px 0 0; }
        .custom-select-option:last-child { border-radius: 0 0 5px 5px; }
        
        .edit-thresholds-btn { width: 32px; height: 32px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-secondary); cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; }
        .edit-thresholds-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
        .host-toolbar-btn { width: 32px; height: 32px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-secondary); cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
        .host-toolbar-btn:hover { background: var(--bg-secondary); color: var(--text-primary); border-color: var(--text-muted); }
        .host-toolbar-btn.spinning { animation: spin 1s linear infinite; pointer-events: none; }
        .add-host-inline { display: flex; align-items: center; }
        .add-host-input-group { display: flex; align-items: center; gap: 4px; }
        .add-host-input { padding: 6px 10px; border: 1px solid var(--accent); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 12px; width: 150px; font-family: 'SF Mono', 'Consolas', monospace; }
        .add-host-input.add-host-user { width: 70px; }
        .add-host-at { color: var(--text-muted); font-size: 12px; font-family: 'SF Mono', 'Consolas', monospace; }
        .add-host-input:focus { outline: none; }
        .add-host-confirm { padding: 6px 8px; border: none; border-radius: 6px; background: var(--success); color: white; font-size: 12px; cursor: pointer; }
        .add-host-confirm:hover { opacity: 0.9; }
        .add-host-cancel { padding: 6px 8px; border: none; border-radius: 6px; background: var(--bg-secondary); color: var(--text-muted); font-size: 12px; cursor: pointer; }
        .add-host-cancel:hover { background: var(--bg-hover); color: var(--text-primary); }
        select, input[type="text"] { padding: 7px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px; background: var(--bg-primary); color: var(--text-primary); }
        .checkbox-label { display: flex; align-items: center; gap: 6px; font-size: 13px; color: var(--text-secondary); cursor: pointer; }
        
        .host-group { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 12px; overflow: hidden; }
        .host-header { padding: 12px 16px; background: var(--bg-hover); display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .host-name { font-size: 14px; font-weight: 600; }
        .host-name-display { font-size: 14px; font-weight: 600; }
        .host-user { font-size: 12px; font-weight: 400; color: var(--text-muted); }
        .host-edit-form { display: inline-flex; align-items: center; gap: 4px; }
        .host-edit-input { padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg-primary); color: var(--text-primary); font-size: 12px; font-family: 'SF Mono', 'Consolas', monospace; }
        .host-edit-input:focus { outline: none; border-color: var(--accent); }
        .host-edit-input.host-edit-user { width: 60px; }
        .host-edit-input.host-edit-ip { width: 120px; }
        .host-edit-at { color: var(--text-muted); font-size: 12px; }
        .host-edit-confirm { padding: 4px 8px; border: none; border-radius: 4px; background: var(--success); color: white; font-size: 12px; cursor: pointer; }
        .host-edit-confirm:hover { opacity: 0.9; }
        .host-edit-cancel { padding: 4px 8px; border: none; border-radius: 4px; background: var(--bg-secondary); color: var(--text-muted); font-size: 12px; cursor: pointer; }
        .host-edit-cancel:hover { background: var(--bg-hover); color: var(--text-primary); }
        .host-badge { font-size: 11px; padding: 2px 8px; border-radius: 12px; font-weight: 500; margin-left: 12px; }
        .host-badge.ok { background: rgba(16,185,129,0.1); color: var(--success); }
        .host-badge.warning { background: rgba(245,158,11,0.1); color: var(--warning); }
        .host-badge.critical { background: rgba(239,68,68,0.1); color: var(--danger); }
        .host-badge.offline { background: rgba(100,116,139,0.15); color: var(--text-muted); }
        .host-badge.pending { background: rgba(59,130,246,0.1); color: var(--accent); }
        .host-group.host-error { opacity: 0.7; }
        .host-group.host-error .host-header { cursor: default; }
        .host-group.host-error .host-name { color: var(--text-secondary); }
        .host-stats { font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 8px; }
        .host-actions { display: flex; gap: 4px; margin-left: 12px; }
        .host-action-btn { padding: 0 8px; height: 24px; border: none; border-radius: 4px; background: var(--bg-primary); color: var(--text-muted); cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; transition: all 0.15s; white-space: nowrap; }
        .host-action-btn.reload { font-size: 14px; }
        .host-action-btn.reload:hover { background: rgba(59,130,246,0.15); color: var(--accent); }
        .host-action-btn.reload.spinning { animation: spin 1s linear infinite; pointer-events: none; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .host-action-btn.edit:hover { background: rgba(59,130,246,0.15); color: var(--accent); }
        .host-action-btn.delete:hover { background: rgba(239,68,68,0.15); color: var(--danger); }
        .host-action-btn.confirming { background: var(--danger); color: white; padding: 0 10px; font-weight: 500; }
        .host-action-btn.confirming:hover { background: #dc2626; }
        .host-toggle { transition: transform 0.2s; }
        .host-group.collapsed .host-toggle { transform: rotate(-90deg); }
        .host-group.collapsed .host-content { display: none; }
        
        .disk-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
        .disk-table th { text-align: left; padding: 10px 14px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); border-bottom: 1px solid var(--border); }
        .disk-table th.sortable { cursor: pointer; user-select: none; transition: color 0.15s; }
        .disk-table th.sortable:hover { color: var(--text-primary); }
        .sort-icon { opacity: 0.4; margin-left: 4px; font-size: 10px; }
        .disk-table th.sortable:hover .sort-icon { opacity: 0.7; }
        .disk-table td { padding: 12px 14px; border-bottom: 1px solid var(--border); font-size: 13px; }
        .disk-table tbody tr { transition: background 0.1s; cursor: pointer; }
        .disk-table tbody tr:hover { background: var(--bg-hover); }
        
        .disk-row.critical { background: rgba(239,68,68,0.04); }
        .disk-row.critical td:first-child { box-shadow: inset 3px 0 0 var(--danger); }
        .disk-row.warning { background: rgba(245,158,11,0.04); }
        .disk-row.warning td:first-child { box-shadow: inset 3px 0 0 var(--warning); }
        
        .device-name { font-weight: 500; font-family: monospace; font-size: 12px; }
        .type-badge { font-size: 9px; padding: 2px 5px; border-radius: 3px; font-weight: 600; margin-left: 8px; text-transform: uppercase; }
        .type-badge.hdd { background: rgba(59,130,246,0.1); color: #3b82f6; }
        .type-badge.ssd { background: rgba(16,185,129,0.1); color: #10b981; }
        .type-badge.nvme { background: rgba(139,92,246,0.1); color: #8b5cf6; }
        .status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
        .status-dot.ok { background: var(--success); }
        .status-dot.fail { background: var(--danger); }
        .issue { font-size: 10px; padding: 2px 6px; border-radius: 3px; font-weight: 500; margin-right: 4px; }
        .issue.warning { background: rgba(245,158,11,0.1); color: var(--warning); }
        .issue.critical { background: rgba(239,68,68,0.1); color: var(--danger); }
        .since-incomplete { color: var(--warning); font-style: italic; cursor: help; }
        .delta-period { font-size: 9px; color: var(--text-muted); font-weight: normal; }
        .data-coverage-info { background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.3); border-radius: 6px; padding: 8px 12px; margin-bottom: 12px; font-size: 12px; color: var(--warning); }
        [data-theme="dark"] .data-coverage-info { background: rgba(245,158,11,0.15); border-color: rgba(245,158,11,0.25); }
        .trend { font-size: 11px; color: var(--warning); }
        .muted { color: var(--text-muted); }
        .mono { font-family: monospace; font-size: 12px; }
        
        .detail-row { display: none; }
        .detail-row.visible { display: table-row; }
        .detail-row td { padding: 0; background: var(--bg-hover); }
        .detail-panel { display: flex; border-top: 1px solid var(--border); }

        .detail-sidebar { min-width: 170px; max-width: 200px; padding: 14px 18px; border-right: 1px solid var(--border); display: flex; flex-direction: column; gap: 14px; background: var(--bg-hover); flex-shrink: 0; }
        .sidebar-item { display: flex; flex-direction: column; gap: 1px; }
        .sb-label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted); }
        .sb-value { font-family: monospace; font-size: 13px; font-weight: 500; color: var(--text-primary); word-break: break-all; }
        .sb-sub { font-size: 10px; color: var(--text-muted); }

        .detail-main { flex: 1; min-width: 0; display: flex; flex-direction: column; }

        .attr-section-header { display: flex; justify-content: space-between; align-items: center; padding: 7px 14px; border-bottom: 1px solid var(--border); background: var(--bg-hover); }
        .attr-section-title { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); }
        .show-all-btn { font-size: 11px; color: var(--accent); cursor: pointer; border: none; background: none; font-family: inherit; font-weight: 500; padding: 2px 0; }
        .show-all-btn:hover { text-decoration: underline; }

        .attr-table { width: 100%; border-collapse: collapse; }
        .attr-table th { text-align: left; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted); padding: 5px 14px; border-bottom: 1px solid var(--border); background: var(--bg-hover); }
        .attr-table th.right { text-align: right; }
        .attr-table td { padding: 5px 14px; font-size: 12px; border-bottom: 1px solid rgba(128,128,128,0.08); vertical-align: middle; }
        .attr-table tr:last-child td { border-bottom: none; }
        .attr-name { color: var(--text-primary); font-weight: 500; }
        .attr-name[data-tip], .attr-value[data-tip] { border-bottom: 1px dotted var(--text-muted); cursor: help; position: relative; }
        .attr-name[data-tip]:hover::after, .attr-value[data-tip]:hover::after { content: attr(data-tip); position: absolute; left: 0; top: calc(100% + 6px); background: var(--bg-primary); color: var(--text-secondary); border: 1px solid var(--border); border-radius: 6px; padding: 8px 11px; font-size: 11px; font-weight: 400; line-height: 1.5; width: 260px; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.12); pointer-events: none; white-space: normal; }
        .attr-value[data-tip] { border-bottom-style: none; }
        .attr-value[data-tip]:hover::after { left: auto; right: 0; width: auto; white-space: nowrap; }
        .attr-id { color: var(--text-muted); font-size: 10px; margin-left: 5px; }
        .attr-value { font-family: monospace; font-size: 12px; font-weight: 500; text-align: right; }
        .attr-value.val-ok { color: var(--text-primary); }
        .attr-value.val-warning { color: var(--warning); }
        .attr-value.val-danger { color: var(--danger); }
        .attr-delta { font-family: monospace; font-size: 11px; text-align: right; color: var(--text-muted); }
        .attr-delta.delta-up { color: var(--warning); }
        .attr-delta.delta-danger { color: var(--danger); }
        .spark-cell { width: 110px; padding: 3px 10px 3px 4px; }
        .spark-cell svg { width: 100px; height: 24px; display: block; }
        .attr-status { width: 24px; text-align: center; font-size: 11px; }
        .secondary-attrs { display: none; }
        .secondary-attrs.visible { display: table-row-group; }

        .detail-footer { padding: 5px 14px; border-top: 1px solid var(--border); font-size: 10px; color: var(--text-muted); background: var(--bg-hover); }
        .detail-footer span { font-family: monospace; color: var(--text-secondary); }
        
        .footer { margin-top: 24px; text-align: center; font-size: 11px; color: var(--text-muted); }
        .loading { text-align: center; padding: 40px; color: var(--text-muted); }
        .error { background: rgba(239,68,68,0.1); color: var(--danger); padding: 12px 16px; border-radius: 8px; margin-bottom: 24px; }
        
        /* === Settings Modal — fully opaque, hardcoded colors === */
        .settings-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .settings-panel { width: 460px; max-width: 92vw; max-height: 82vh; border-radius: 10px; display: flex; flex-direction: column; overflow: hidden; background: #f0f2f5; color: #1a1a2e; box-shadow: 0 8px 40px rgba(0,0,0,0.25); }
        .settings-header { padding: 14px 18px; display: flex; justify-content: space-between; align-items: center; background: #ffffff; border-bottom: 1px solid #d5d9e0; flex-shrink: 0; }
        .settings-header h2 { font-size: 15px; font-weight: 700; margin: 0; }
        .settings-close { width: 28px; height: 28px; border-radius: 6px; border: none; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; background: #e8eaed; color: #555; }
        .settings-close:hover { background: #d0d3d8; }
        .settings-body { padding: 16px 18px; overflow-y: auto; flex: 1; scrollbar-width: thin; scrollbar-color: transparent transparent; }
        .settings-body:hover { scrollbar-color: rgba(150,150,150,0.4) transparent; }
        .settings-body::-webkit-scrollbar { width: 6px; }
        .settings-body::-webkit-scrollbar-track { background: transparent; }
        .settings-body::-webkit-scrollbar-thumb { background: transparent; border-radius: 3px; }
        .settings-body:hover::-webkit-scrollbar-thumb { background: rgba(150,150,150,0.4); }
        .settings-body::-webkit-scrollbar-thumb:hover { background: rgba(150,150,150,0.6); }
        [data-theme="dark"] .settings-body:hover { scrollbar-color: rgba(200,200,200,0.2) transparent; }
        [data-theme="dark"] .settings-body:hover::-webkit-scrollbar-thumb { background: rgba(200,200,200,0.2); }
        [data-theme="dark"] .settings-body::-webkit-scrollbar-thumb:hover { background: rgba(200,200,200,0.35); }
        .settings-section-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; color: #555; }
        .settings-section-hint { font-size: 12px; color: #777; margin: 0 0 10px 0; }
        .hosts-editor { display: flex; flex-direction: column; gap: 4px; margin-bottom: 8px; }
        .host-row { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: #ffffff; border: 1px solid #d5d9e0; border-radius: 6px; font-size: 13px; font-family: 'SF Mono', 'Consolas', monospace; }
        .host-row .host-addr { flex: 1; }
        .host-row .host-remove { width: 22px; height: 22px; border-radius: 4px; border: none; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; background: transparent; color: #999; }
        .host-row .host-remove:hover { background: #fee2e2; color: #dc2626; }
        .host-meta { font-size: 11px; color: #888; font-family: inherit; white-space: nowrap; }
        .host-status { font-size: 10px; padding: 1px 6px; border-radius: 4px; font-weight: 600; }
        .host-new { background: #e0f2fe; color: #0284c7; }
        [data-theme="dark"] .host-meta { color: #64748b; }
        [data-theme="dark"] .host-new { background: #0c4a6e; color: #7dd3fc; }
        .hosts-actions { display: flex; gap: 6px; margin-bottom: 4px; }
        .host-input { flex: 1; padding: 6px 10px; border: 1px solid #d5d9e0; border-radius: 6px; font-size: 13px; font-family: 'SF Mono', 'Consolas', monospace; background: #ffffff; color: #1a1a2e; outline: none; }
        .host-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,0.15); }
        .host-add-btn { padding: 6px 14px; border: none; border-radius: 6px; background: #3b82f6; color: white; font-size: 12px; font-weight: 600; cursor: pointer; }
        .host-add-btn:hover { background: #2563eb; }
        [data-theme="dark"] .host-row { background: #1a2538; border-color: #2a3a52; color: #e2e8f0; }
        [data-theme="dark"] .host-row .host-remove:hover { background: #7f1d1d; color: #fca5a5; }
        [data-theme="dark"] .host-input { background: #1a2538; border-color: #2a3a52; color: #e2e8f0; }
        [data-theme="dark"] .host-input:focus { border-color: #3b82f6; }
        /* Dark mode overrides */
        [data-theme="dark"] .settings-panel { background: #141c2b; color: #e2e8f0; box-shadow: 0 8px 40px rgba(0,0,0,0.6); }
        [data-theme="dark"] .settings-header { background: #1a2538; border-color: #2a3a52; }
        [data-theme="dark"] .settings-header h2 { color: #e2e8f0; }
        [data-theme="dark"] .settings-close { background: #2a3a52; color: #94a3b8; }
        [data-theme="dark"] .settings-close:hover { background: #334766; }
        [data-theme="dark"] .settings-section-title { color: #94a3b8; }
        [data-theme="dark"] .settings-section-hint { color: #64748b; }
        
        /* Threshold Editor */
        .threshold-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(2px); }
        .threshold-overlay.visible { display: flex; }
        .threshold-panel { background: #ffffff; border-radius: 12px; width: 580px; max-width: 95vw; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 8px 40px rgba(0,0,0,0.3); }
        .threshold-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid #e5e7eb; background: #f8fafc; border-radius: 12px 12px 0 0; }
        .threshold-header h2 { margin: 0; font-size: 16px; font-weight: 600; color: #1a1a2e; }
        .threshold-close { width: 28px; height: 28px; border: none; border-radius: 6px; background: #e5e7eb; color: #666; cursor: pointer; font-size: 14px; }
        .threshold-close:hover { background: #d1d5db; }
        .threshold-body { padding: 20px; overflow-y: auto; background: #ffffff; border-radius: 0 0 12px 12px; }
        .preset-buttons { display: flex; gap: 8px; margin-bottom: 8px; }
        .preset-btn { flex: 1; padding: 10px 16px; border: 2px solid #e5e7eb; border-radius: 8px; background: #ffffff; color: #374151; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.15s; }
        .preset-btn:hover { border-color: #9ca3af; }
        .preset-btn.active { border-color: #3b82f6; background: #eff6ff; color: #3b82f6; }
        .preset-hint { font-size: 12px; color: #6b7280; margin: 0 0 16px 0; }
        .threshold-section { margin-bottom: 20px; }
        .threshold-section:last-child { margin-bottom: 0; }
        .threshold-section-title { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #6b7280; margin-bottom: 8px; }
        .threshold-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .threshold-table th { text-align: left; font-weight: 500; color: #6b7280; padding: 6px 8px; border-bottom: 1px solid #e5e7eb; }
        .threshold-table td { padding: 6px 8px; border-bottom: 1px solid #e5e7eb; }
        .threshold-table td:first-child { color: #374151; }
        .threshold-input { display: flex; align-items: center; gap: 4px; }
        .threshold-input select { width: 50px; padding: 4px; border: 1px solid #d1d5db; border-radius: 4px; background: #ffffff; color: #374151; font-size: 12px; }
        .threshold-input input { width: 60px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; background: #ffffff; color: #374151; font-size: 12px; text-align: center; }
        .threshold-input input:disabled, .threshold-input select:disabled { opacity: 0.4; }
        .threshold-input .unit { font-size: 11px; color: #9ca3af; }
        [data-theme="dark"] .threshold-panel { background: #1a2332; }
        [data-theme="dark"] .threshold-header { background: #141c2b; border-color: #2a3a52; }
        [data-theme="dark"] .threshold-header h2 { color: #e2e8f0; }
        [data-theme="dark"] .threshold-close { background: #2a3a52; color: #94a3b8; }
        [data-theme="dark"] .threshold-close:hover { background: #334766; }
        [data-theme="dark"] .threshold-body { background: #1a2332; }
        [data-theme="dark"] .preset-btn { background: #141c2b; border-color: #2a3a52; color: #e2e8f0; }
        [data-theme="dark"] .preset-btn:hover { border-color: #4a5568; }
        [data-theme="dark"] .preset-btn.active { background: rgba(59,130,246,0.15); border-color: #3b82f6; }
        [data-theme="dark"] .preset-hint { color: #64748b; }
        [data-theme="dark"] .threshold-section-title { color: #94a3b8; }
        [data-theme="dark"] .threshold-table th { color: #94a3b8; border-color: #2a3a52; }
        [data-theme="dark"] .threshold-table td { color: #e2e8f0; border-color: #2a3a52; }
        [data-theme="dark"] .threshold-input select, [data-theme="dark"] .threshold-input input { background: #141c2b; border-color: #2a3a52; color: #e2e8f0; }
        
        @media (max-width: 900px) { .stats { grid-template-columns: repeat(2, 1fr); } .filters { flex-direction: column; align-items: stretch; } }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>diskmind</h1>
            <div class="header-right">
                <span class="timestamp" id="lastUpdate">Loading...</span>
                <button class="btn" onclick="toggleTheme()" id="themeBtn" title="Toggle theme">☀️</button>
                <button class="btn" onclick="toggleSettings()" id="settingsBtn" title="Settings">⚙️</button>
                <button class="btn primary" id="refreshBtn" onclick="refresh()">↻ Refresh</button>
            </div>
        </header>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="settingsOverlay" class="settings-overlay" style="display:none;" onclick="if(event.target===this)toggleSettings()">
            <div class="settings-panel" style="width: 320px;">
                <div class="settings-header">
                    <h2>Settings</h2>
                    <button class="settings-close" onclick="toggleSettings()">✕</button>
                </div>
                <div class="settings-body">
                    <div class="settings-section-title">Temperature Unit</div>
                    <p class="settings-section-hint">Display temperatures in Celsius or Fahrenheit.</p>
                    <select id="tempUnitSelect" class="host-input" style="width:100%" onchange="saveTempUnit()">
                        <option value="C">Celsius (°C)</option>
                        <option value="F">Fahrenheit (°F)</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Threshold Editor Popup -->
        <div class="threshold-overlay" id="thresholdOverlay" onclick="if(event.target===this)toggleThresholdEditor()">
            <div class="threshold-panel">
                <div class="threshold-header">
                    <h2>Threshold Settings</h2>
                    <button class="threshold-close" onclick="toggleThresholdEditor()">✕</button>
                </div>
                <div class="threshold-body">
                    <div class="preset-buttons">
                        <button class="preset-btn" data-preset="relaxed" onclick="selectPreset('relaxed')">Relaxed</button>
                        <button class="preset-btn" data-preset="conservative" onclick="selectPreset('conservative')">Conservative</button>
                        <button class="preset-btn" data-preset="backblaze" onclick="selectPreset('backblaze')">Backblaze</button>
                        <button class="preset-btn" data-preset="custom" onclick="selectPreset('custom')">Custom</button>
                    </div>
                    <p class="preset-hint" id="presetHint">Relaxed: Higher thresholds for home/lab use. Fewer alerts.</p>
                    
                    <div class="threshold-section">
                        <div class="threshold-section-title">ATA / SATA (HDD & SSD)</div>
                        <table class="threshold-table" id="ataThresholds">
                            <thead><tr><th>Attribute</th><th>Warning</th><th>Critical</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    
                    <div class="threshold-section">
                        <div class="threshold-section-title">NVMe</div>
                        <table class="threshold-table" id="nvmeThresholds">
                            <thead><tr><th>Attribute</th><th>Warning</th><th>Critical</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat" onclick="filterStatus('')">
                <div class="stat-label">Total</div>
                <div class="stat-value" id="statTotal">-</div>
                <div class="stat-sub" id="statCapacity">-</div>
            </div>
            <div class="stat healthy" onclick="filterStatus('ok')">
                <div class="stat-label">Healthy</div>
                <div class="stat-value" id="statHealthy">-</div>
                <div class="stat-sub">No Issues</div>
            </div>
            <div class="stat warning" onclick="filterStatus('warning')">
                <div class="stat-label">Warning</div>
                <div class="stat-value" id="statWarning">-</div>
                <div class="stat-sub">Sector Issues</div>
            </div>
            <div class="stat critical" onclick="filterStatus('critical')">
                <div class="stat-label">Critical</div>
                <div class="stat-value" id="statCritical">-</div>
                <div class="stat-sub">SMART Failed</div>
            </div>
        </div>
        
        <div class="filters">
            <div class="filter-group-labeled">
                <span class="filter-group-label">Disks</span>
                <div class="filter-group-controls">
                    <div class="custom-select" id="typeFilterWrapper">
                        <div class="custom-select-trigger" onclick="toggleDropdown('typeFilterWrapper')">
                            <span class="custom-select-value">All Types</span>
                            <span class="custom-select-arrow">▼</span>
                        </div>
                        <div class="custom-select-options">
                            <div class="custom-select-option selected" data-value="">All Types</div>
                            <div class="custom-select-option" data-value="HDD">HDD</div>
                            <div class="custom-select-option" data-value="SSD">SSD</div>
                            <div class="custom-select-option" data-value="NVMe">NVMe</div>
                        </div>
                    </div>
                    <input type="hidden" id="typeFilter" value="">
                    <input type="text" id="search" placeholder="Search..." onkeyup="applyFilters()">
                </div>
            </div>
            <div class="filter-separator"></div>
            <div class="filter-group-labeled">
                <span class="filter-group-label">Thresholds <span class="info-icon" data-tip="Warning/critical limits for SMART values. Click ⚙ for details.">ⓘ</span></span>
                <div class="filter-group-controls">
                    <div class="custom-select" id="presetFilterWrapper">
                        <div class="custom-select-trigger" onclick="toggleDropdown('presetFilterWrapper')">
                            <span class="custom-select-value">Backblaze</span>
                            <span class="custom-select-arrow">▼</span>
                        </div>
                        <div class="custom-select-options">
                            <div class="custom-select-option" data-value="relaxed">Relaxed</div>
                            <div class="custom-select-option" data-value="conservative">Conservative</div>
                            <div class="custom-select-option selected" data-value="backblaze">Backblaze</div>
                            <div class="custom-select-option" data-value="custom">Custom</div>
                        </div>
                    </div>
                    <input type="hidden" id="presetFilter" value="backblaze">
                    <button class="edit-thresholds-btn" onclick="toggleThresholdEditor()" title="Edit thresholds">⚙</button>
                </div>
            </div>
            <div class="filter-separator"></div>
            <div class="filter-group-labeled">
                <span class="filter-group-label">History <span class="info-icon" data-tip="Time range for issue detection. Event counters only alert if they increased within this period.">ⓘ</span></span>
                <div class="filter-group-controls">
                    <div class="custom-select" id="deltaRangeWrapper">
                        <div class="custom-select-trigger" onclick="toggleDropdown('deltaRangeWrapper')">
                            <span class="custom-select-value">7 days</span>
                            <span class="custom-select-arrow">▼</span>
                        </div>
                        <div class="custom-select-options">
                            <div class="custom-select-option" data-value="1h">1 hour</div>
                            <div class="custom-select-option" data-value="24h">24 hours</div>
                            <div class="custom-select-option selected" data-value="7d">7 days</div>
                            <div class="custom-select-option" data-value="30d">30 days</div>
                            <div class="custom-select-option" data-value="90d">90 days</div>
                            <div class="custom-select-option" data-value="all">all time</div>
                        </div>
                    </div>
                    <input type="hidden" id="deltaRange" value="7d">
                </div>
            </div>
            <div class="filter-separator"></div>
            <div class="filter-group-labeled">
                <span class="filter-group-label">Hosts</span>
                <div class="filter-group-controls">
                    <div class="custom-select" id="hostFilterWrapper">
                        <div class="custom-select-trigger" onclick="toggleDropdown('hostFilterWrapper')">
                            <span class="custom-select-value">All Hosts</span>
                            <span class="custom-select-arrow">▼</span>
                        </div>
                        <div class="custom-select-options">
                            <div class="custom-select-option selected" data-value="">All Hosts</div>
                        </div>
                    </div>
                    <input type="hidden" id="hostFilter" value="">
                    <button class="host-toolbar-btn" onclick="refreshAllHosts()" title="Fetch SMART data">↻</button>
                    <button id="addHostBtn" class="host-toolbar-btn" onclick="showAddHostInput()" title="Add host">+</button>
                </div>
                <div id="addHostInline" class="add-host-input-group" style="display:none;">
                    <input type="text" id="addHostUser" class="add-host-input add-host-user" placeholder="user" title="SSH user (leave empty for root)">
                    <span class="add-host-at">@</span>
                    <input type="text" id="addHostInput" class="add-host-input" placeholder="IP or hostname" onkeydown="handleAddHostKey(event)">
                    <button class="add-host-confirm" onclick="addHostFromInput()">✓</button>
                    <button class="add-host-cancel" onclick="hideAddHostInput()">✕</button>
                </div>
            </div>
        </div>
        
        <div id="content"><div class="loading">Loading...</div></div>
        
        <footer class="footer">diskmind v1.4</footer>
    </div>
    
    <script>
    let data = { disks: [], hosts: [], stats: {}, trends: {}, thresholds: {} };
    let historyCache = {};
    let statusFilter = '';
    let deltaRangeDays = 30;
    let settingsData = null;
    let tempUnit = 'C'; // 'C' for Celsius, 'F' for Fahrenheit

    // Health-relevant attributes by type (order matters - shown first)
    // Attribute descriptions for tooltips
    const ATTR_TIPS = {
        // ATA health
        'Reallocated_Sector_Ct': 'Number of defective sectors moved to a reserved spare area. A slowly rising count is normal aging; rapid growth suggests surface degradation.',
        'Reported_Uncorrect': 'Read or write errors that the error correction could not fix. Occasional errors can occur; a growing count points to media problems.',
        'Command_Timeout': 'Operations the drive failed to complete in time. Often caused by cable, power supply, or controller issues rather than the drive itself.',
        'Current_Pending_Sector': 'Sectors flagged as suspicious, waiting to be tested on the next write. May resolve on their own or become reallocated.',
        'Offline_Uncorrectable': 'Bad sectors found during background scans that could not be repaired or remapped. Indicates permanent media damage at those locations.',
        'Temperature_Celsius': 'Current drive temperature in \u00b0C. Most drives are rated for continuous operation up to 55-60\u00b0C.',
        'Airflow_Temperature_Cel': 'Current drive temperature in \u00b0C. Most drives are rated for continuous operation up to 55-60\u00b0C.',
        // ATA secondary
        'Raw_Read_Error_Rate': 'Rate of hardware read errors. On Seagate drives this is a composite value where the large raw number is normal and not an error count.',
        'Spin_Up_Time': 'Time in milliseconds for the platters to reach operating speed. Increases can indicate motor or bearing wear.',
        'Start_Stop_Count': 'Number of spindle start/stop cycles. Drives are typically rated for 50,000 or more cycles.',
        'Seek_Error_Rate': 'Rate of positioning errors when the head moves to a track. On Seagate drives this is a composite value; the large raw number is normal.',
        'Spin_Retry_Count': 'Number of times the drive needed more than one attempt to spin up. Non-zero values can point to power supply or motor issues.',
        'Power_Off_Retract_Count': 'Times the heads retracted due to power loss rather than a clean shutdown. Normal for drives that experience occasional outages.',
        'Load_Cycle_Count': 'Number of head load/unload cycles. Drives are typically rated for 300,000-600,000 cycles over their lifetime.',
        'UDMA_CRC_Error_Count': 'Data transfer errors between drive and controller, usually caused by a damaged or loose SATA cable.',
        'Multi_Zone_Error_Rate': 'Rate of errors when writing data across multiple zones. Can indicate problems with the write head or media surface.',
        'Head_Flying_Hours': 'Total time the read/write heads have been positioned over the platters. Similar to power-on hours but excludes idle/parked time.',
        'Total_LBAs_Written': 'Total logical block addresses written. Multiply by 512 bytes for approximate total data written to the drive.',
        'Total_LBAs_Read': 'Total logical block addresses read. Multiply by 512 bytes for approximate total data read from the drive.',
        'Power_On_Hours': 'Total accumulated hours the drive has been powered on.',
        'Power_Cycle_Count': 'Number of full power on/off cycles. Frequent cycling can stress components more than continuous operation.',
        'End-to-End_Error': 'Errors detected in the data path between the drive cache and the host interface. Should normally be zero.',
        'Runtime_Bad_Block': 'Bad blocks found during normal operation. Similar to reallocated sectors but tracked separately by some vendors.',
        'High_Fly_Writes': 'Write operations where the head was further from the platter surface than intended. Can lead to weak writes.',
        'G-Sense_Error_Rate': 'Shock and vibration events detected by the built-in accelerometer. Common in portable or poorly mounted drives.',
        'Hardware_ECC_Recovered': 'Number of errors corrected by hardware error correction. A rising count is normal as the drive ages.',
        // NVMe health
        'Percentage_Used': 'Vendor estimate of life consumed based on actual writes vs. rated endurance (TBW). Reaching 100% means the rated lifespan is used up, though many drives continue to work beyond that.',
        'Available_Spare': 'Percentage of reserved spare flash blocks still available for wear leveling. Starts at 100% and decreases over the lifetime of the drive.',
        'Available_Spare_Threshold': 'Vendor-defined minimum for available spare blocks. When Available Spare drops below this value, the drive raises a warning.',
        'Critical_Warning': 'Hardware-level warning flags reported by the NVMe controller. A value of 0 means no warnings are active.',
        'Media_and_Data_Integrity_Errors': 'Count of unrecovered data errors from the flash media. A value of 0 is expected; any increase means cells are failing.',
        'Error_Information_Log_Entries': 'Total number of error events logged by the drive. Some entries are normal over time; a sudden jump can indicate a new issue.',
        'Temperature': 'Current drive temperature in \u00b0C. NVMe drives typically throttle performance above 70\u00b0C to protect themselves.',
        'Unsafe_Shutdowns': 'Number of times the drive lost power without a clean shutdown command. Does not directly indicate damage, but high counts increase the risk of metadata issues.',
        // NVMe secondary
        'Data_Units_Read': 'Total data read in 512-byte units x1000. Divide by ~2 million to approximate terabytes read.',
        'Data_Units_Written': 'Total data written in 512-byte units x1000. Divide by ~2 million to approximate terabytes written.',
        'Host_Read_Commands': 'Total number of read commands issued by the host system.',
        'Host_Write_Commands': 'Total number of write commands issued by the host system.',
        'Controller_Busy_Time': 'Total time in minutes that the controller was busy handling I/O commands.',
        'Warning_Comp._Temperature_Time': 'Total minutes the drive spent above its warning temperature threshold.',
        'Critical_Comp._Temperature_Time': 'Total minutes the drive spent above its critical temperature threshold. Any non-zero value means the drive was at risk of damage.',
        'Temperature_Sensor_1': 'Reading from the first on-board temperature sensor, typically near the controller.',
        'Temperature_Sensor_2': 'Reading from the second on-board temperature sensor, typically near the NAND flash.',
        'Thermal_Temp._1_Transition_Count': 'Number of times the drive crossed into thermal throttling state 1 to manage heat.',
        'Thermal_Temp._1_Total_Time': 'Total time spent in thermal throttling state 1.',
    };

    const HEALTH_ATTRS = {
        ata: [
            {key: 'Reallocated_Sector_Ct', id: 5, label: 'Reallocated Sector Ct'},
            {key: 'Reported_Uncorrect', id: 187, label: 'Reported Uncorrect'},
            {key: 'Command_Timeout', id: 188, label: 'Command Timeout'},
            {key: 'Current_Pending_Sector', id: 197, label: 'Current Pending Sector'},
            {key: 'Offline_Uncorrectable', id: 198, label: 'Offline Uncorrectable'},
            {key: 'Temperature_Celsius', id: 194, label: 'Temperature'},
        ],
        nvme: [
            {key: 'Percentage_Used', label: 'Percentage Used'},
            {key: 'Available_Spare', label: 'Available Spare'},
            {key: 'Critical_Warning', label: 'Critical Warning'},
            {key: 'Media_and_Data_Integrity_Errors', label: 'Media & Data Integrity Errors'},
            {key: 'Error_Information_Log_Entries', label: 'Error Log Entries'},
            {key: 'Temperature', label: 'Temperature'},
        ]
    };
    // Alternate temperature key for ATA
    const TEMP_KEYS = ['Temperature_Celsius', 'Airflow_Temperature_Cel', 'Temperature'];

    // Key metrics shown in the top strip
    const KEY_METRIC_ATTRS = ['Power_On_Hours', 'Power_Cycle_Count', 'Power_Cycles'];

    function getTemp(attrs) {
        for (const k of TEMP_KEYS) { if (attrs[k] != null) return attrs[k]; }
        return null;
    }
    
    function formatTemp(celsius) {
        if (celsius == null || celsius === '-') return '-';
        const c = parseInt(celsius);
        if (isNaN(c)) return '-';
        if (tempUnit === 'F') {
            return Math.round(c * 9/5 + 32);
        }
        return c;
    }
    
    function getTempSymbol() {
        return tempUnit === 'F' ? '°F' : '°C';
    }

    function fmtHours(h) {
        if (!h) return '-';
        h = parseInt(h);
        if (h >= 1000) return (h / 1000).toFixed(1) + 'k';
        return String(h);
    }

    function fmtDuration(h) {
        if (!h) return '';
        h = parseInt(h);
        const days = Math.round(h / 24);
        if (days >= 365) {
            const years = (days / 365).toFixed(1);
            return years + (years === '1.0' ? ' year' : ' years');
        }
        if (days >= 30) {
            const months = Math.round(days / 30.44);
            return months + (months === 1 ? ' month' : ' months');
        }
        if (days >= 7) {
            const weeks = Math.round(days / 7);
            return weeks + (weeks === 1 ? ' week' : ' weeks');
        }
        return days + (days === 1 ? ' day' : ' days');
    }

    function fmtBytes(bytes) {
        if (!bytes || bytes <= 0) return '0 B';
        const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        const val = bytes / Math.pow(1024, i);
        return val.toFixed(val >= 100 ? 0 : val >= 10 ? 1 : 2) + ' ' + units[i];
    }

    // Keys that should be displayed as human-readable byte values
    const LBA_KEYS = new Set(['Total_LBAs_Written', 'Total_LBAs_Read']);
    const DATA_UNIT_KEYS = new Set(['Data_Units_Read', 'Data_Units_Written']);

    // SVG sparkline generator
    function sparkSVG(points, color, opts = {}) {
        if (!points || points.length < 2) {
            // Flat dashed line for no data or single point
            const y = 20;
            return `<svg viewBox="0 0 100 24" preserveAspectRatio="none"><line x1="0" y1="${y}" x2="100" y2="${y}" stroke="currentColor" stroke-width="1" stroke-dasharray="3,3" opacity="0.25"/></svg>`;
        }
        const w = 100, h = 24, pad = 2;
        let min = Math.min(...points), max = Math.max(...points);
        if (min === max) { min -= 1; max += 1; } // avoid div by zero
        const range = max - min;
        const coords = points.map((v, i) => {
            const x = (i / (points.length - 1)) * w;
            const y = pad + (1 - (v - min) / range) * (h - 2 * pad);
            return `${x.toFixed(1)},${y.toFixed(1)}`;
        });
        const line = coords.join(' L');
        const fill = coords.join(' L') + ` L${w},${h} L0,${h} Z`;
        const fillColor = color === '#f59e0b' ? 'rgba(245,158,11,0.12)' :
                          color === '#ef4444' ? 'rgba(239,68,68,0.12)' :
                          color === '#10b981' ? 'rgba(16,185,129,0.08)' :
                          'rgba(59,130,246,0.08)';
        return `<svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">
            <path d="M${fill}" fill="${fillColor}"/>
            <path d="M${line}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linejoin="round"/>
        </svg>`;
    }

    // Seagate composite value decoder
    // Seagate packs multiple counters into 48-bit raw values:
    // - Command_Timeout (#188): [5-4]=cmds>7.5s, [3-2]=cmds>5s, [1-0]=actual timeouts
    // - Raw_Read_Error_Rate (#1): [5-4]=error count, [3-0]=total operations
    // - Seek_Error_Rate (#7): [5-4]=error count, [3-0]=total seeks
    const SEAGATE_COMPOSITE_ATTRS = {
        'Command_Timeout': { extract: 'low16' },       // actual timeouts in low 16 bits
        'Raw_Read_Error_Rate': { extract: 'high16' },   // errors in high 16 bits
        'Seek_Error_Rate': { extract: 'high16' },       // errors in high 16 bits
    };

    function isSeagateComposite(attrKey, rawValue) {
        if (!SEAGATE_COMPOSITE_ATTRS[attrKey]) return false;
        // Composite values are >65535 (more than 16 bits used)
        return parseInt(rawValue) > 65535;
    }

    function decodeSeagateValue(attrKey, rawValue) {
        const raw = parseInt(rawValue);
        if (!isSeagateComposite(attrKey, rawValue)) return raw;
        const spec = SEAGATE_COMPOSITE_ATTRS[attrKey];
        if (spec.extract === 'low16') return raw & 0xFFFF;
        if (spec.extract === 'high16') return (raw >> 32) & 0xFFFF;
        return raw;
    }
    
    // Custom dropdown functions
    function toggleDropdown(wrapperId) {
        const wrapper = document.getElementById(wrapperId);
        const wasOpen = wrapper.classList.contains('open');
        
        // Close all dropdowns
        document.querySelectorAll('.custom-select.open').forEach(el => el.classList.remove('open'));
        
        // Toggle this one
        if (!wasOpen) {
            wrapper.classList.add('open');
        }
    }
    
    function selectOption(wrapperId, value, label, callback) {
        const wrapper = document.getElementById(wrapperId);
        const hiddenInput = wrapper.nextElementSibling;
        const valueDisplay = wrapper.querySelector('.custom-select-value');
        
        // Update hidden input
        if (hiddenInput && hiddenInput.tagName === 'INPUT') {
            hiddenInput.value = value;
        }
        
        // Update displayed value
        valueDisplay.textContent = label;
        
        // Update selected state
        wrapper.querySelectorAll('.custom-select-option').forEach(opt => {
            opt.classList.toggle('selected', opt.dataset.value === value);
        });
        
        // Close dropdown
        wrapper.classList.remove('open');
        
        // Execute callback
        if (callback) callback(value);
    }
    
    function initDropdowns() {
        // Add click handlers to all options
        document.querySelectorAll('.custom-select-option').forEach(opt => {
            opt.addEventListener('click', (e) => {
                e.stopPropagation();
                const wrapper = opt.closest('.custom-select');
                const value = opt.dataset.value;
                const label = opt.textContent;
                
                // Determine callback based on wrapper id
                let callback = null;
                if (wrapper.id === 'typeFilterWrapper') callback = applyFilters;
                else if (wrapper.id === 'presetFilterWrapper') callback = (v) => changePreset(v);
                else if (wrapper.id === 'deltaRangeWrapper') callback = (v) => updateDeltaFromDropdown(v);
                else if (wrapper.id === 'hostFilterWrapper') callback = applyFilters;
                
                selectOption(wrapper.id, value, label, callback);
            });
        });
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.custom-select')) {
                document.querySelectorAll('.custom-select.open').forEach(el => el.classList.remove('open'));
            }
        });
    }
    
    function setDropdownValue(wrapperId, value) {
        const wrapper = document.getElementById(wrapperId);
        if (!wrapper) return;
        
        const option = wrapper.querySelector(`.custom-select-option[data-value="${value}"]`);
        if (option) {
            const label = option.textContent;
            const valueDisplay = wrapper.querySelector('.custom-select-value');
            const hiddenInput = wrapper.nextElementSibling;
            
            if (hiddenInput && hiddenInput.tagName === 'INPUT') {
                hiddenInput.value = value;
            }
            valueDisplay.textContent = label;
            
            wrapper.querySelectorAll('.custom-select-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === value);
            });
        }
    }
    
    // Format time duration: <1h = Xmin, <1d = Xh, else Xd
    function formatDuration(ms) {
        const minutes = ms / 60000;
        const hours = ms / 3600000;
        const days = ms / 86400000;
        if (days >= 1) return Math.floor(days) + 'd';
        if (hours >= 1) return Math.floor(hours) + 'h';
        return Math.max(1, Math.floor(minutes)) + 'min';
    }

    function getAttrColor(attrKey, value, diskType) {
        // Decode Seagate composites before threshold check
        const checkVal = (diskType !== 'NVMe') ? decodeSeagateValue(attrKey, value) : value;
        // Check against current thresholds
        const th = data.thresholds || {};
        const ruleSet = diskType === 'NVMe' ? (th.nvme || {}) : (th.ata || {});
        for (const [attr, rule] of Object.entries(ruleSet.critical || {})) {
            if (attr === attrKey && checkThreshold(checkVal, rule)) return '#ef4444';
        }
        for (const [attr, rule] of Object.entries(ruleSet.warning || {})) {
            if (attr === attrKey && checkThreshold(checkVal, rule)) return '#f59e0b';
        }
        // Temperature: always blue sparkline
        if (TEMP_KEYS.includes(attrKey) || attrKey === 'Temperature') return '#3b82f6';
        return '#3b82f6';
    }

    function checkThreshold(val, rule) {
        const v = parseFloat(val), t = rule.value;
        if (isNaN(v)) return false;
        if (rule.op === '>') return v > t;
        if (rule.op === '>=') return v >= t;
        if (rule.op === '<') return v < t;
        if (rule.op === '<=') return v <= t;
        if (rule.op === '==') return v === t;
        return false;
    }
    
    // Cumulative event counters - used for display hints (delta suffix)
    // Actual filtering is now done in backend
    const CUMULATIVE_EVENT_ATTRS = new Set([
        'Command_Timeout',
        'Reported_Uncorrect', 
        'UDMA_CRC_Error_Count',
        'Unsafe_Shutdowns',
        'Error_Information_Log_Entries',
        'Power_Off_Retract_Count',
        'G-Sense_Error_Rate',
    ]);

    function getValClass(attrKey, value, diskType) {
        const checkVal = (diskType !== 'NVMe') ? decodeSeagateValue(attrKey, value) : value;
        const th = data.thresholds || {};
        const ruleSet = diskType === 'NVMe' ? (th.nvme || {}) : (th.ata || {});
        for (const [attr, rule] of Object.entries(ruleSet.critical || {})) {
            if (attr === attrKey && checkThreshold(checkVal, rule)) return 'val-danger';
        }
        for (const [attr, rule] of Object.entries(ruleSet.warning || {})) {
            if (attr === attrKey && checkThreshold(checkVal, rule)) return 'val-warning';
        }
        return 'val-ok';
    }

    function getValTip(attrKey, value, diskType, composite) {
        const checkVal = (diskType !== 'NVMe') ? decodeSeagateValue(attrKey, value) : value;
        const th = data.thresholds || {};
        const ruleSet = diskType === 'NVMe' ? (th.nvme || {}) : (th.ata || {});
        let level = '', rule = null;
        for (const [attr, r] of Object.entries(ruleSet.critical || {})) {
            if (attr === attrKey && checkThreshold(checkVal, r)) { level = 'Critical'; rule = r; break; }
        }
        if (!level) {
            for (const [attr, r] of Object.entries(ruleSet.warning || {})) {
                if (attr === attrKey && checkThreshold(checkVal, r)) { level = 'Warning'; rule = r; break; }
            }
        }
        if (!level) return '';
        const opLabel = rule.op === '>' ? 'above' : rule.op === '>=' ? 'at or above' : rule.op === '<' ? 'below' : rule.op === '<=' ? 'at or below' : '';
        let tip = `${level}: ${checkVal} is ${opLabel} ${rule.value}`;
        if (composite) tip += ` (decoded from raw ${value})`;
        return tip;
    }

    function getStatusIcon(attrKey, value, diskType) {
        const checkVal = (diskType !== 'NVMe') ? decodeSeagateValue(attrKey, value) : value;
        const th = data.thresholds || {};
        const ruleSet = diskType === 'NVMe' ? (th.nvme || {}) : (th.ata || {});
        for (const [attr, rule] of Object.entries(ruleSet.critical || {})) {
            if (attr === attrKey && checkThreshold(checkVal, rule)) return '<span style="color:var(--danger)">✕</span>';
        }
        for (const [attr, rule] of Object.entries(ruleSet.warning || {})) {
            if (attr === attrKey && checkThreshold(checkVal, rule)) return '<span style="color:var(--warning)">⚠</span>';
        }
        // Only show checkmark for health-monitored attributes
        const healthKeys = [...(HEALTH_ATTRS.ata || []), ...(HEALTH_ATTRS.nvme || [])].map(a => a.key);
        if (healthKeys.includes(attrKey) && !TEMP_KEYS.includes(attrKey) && attrKey !== 'Temperature') {
            return '<span style="color:var(--success)">✓</span>';
        }
        return '';
    }

    function renderAttrRow(attrDef, attrs, hist, diskType, showId, dataCoversFilter, dataAgeMs) {
        const key = attrDef.key;
        let val = attrs[key];
        // Temperature fallback
        if (val == null && TEMP_KEYS.includes(key)) {
            for (const tk of TEMP_KEYS) { if (attrs[tk] != null) { val = attrs[tk]; break; } }
        }
        if (val == null) val = 0;

        // Decode Seagate composite values for display and threshold checks
        let displayVal = val;
        let composite = false;
        if (diskType !== 'NVMe' && isSeagateComposite(key, val)) {
            displayVal = decodeSeagateValue(key, val);
            composite = true;
        }

        const h = hist ? hist[key] : null;
        const delta = h ? h.delta : 0;
        const points = h ? h.points : null;
        const color = getAttrColor(key, val, diskType);
        const valClass = getValClass(key, val, diskType);
        const statusIcon = getStatusIcon(key, val, diskType);
        const valTip = getValTip(key, val, diskType, composite);
        const idStr = showId && attrDef.id ? `<span class="attr-id">#${attrDef.id}</span>` : '';

        let deltaStr = '—';
        let deltaClass = '';
        if (delta > 0) { 
            deltaStr = `+${delta} ↑`; 
            deltaClass = 'delta-up'; 
        } else if (delta < 0) { 
            deltaStr = `${delta} ↓`; 
        }
        
        // Add period suffix if data doesn't cover filter period
        if (delta !== 0 && !dataCoversFilter && dataAgeMs > 0) {
            deltaStr += ` <span class="delta-period">(${formatDuration(dataAgeMs)})</span>`;
        }

        // Suffix for special attrs
        let suffix = '';
        if (key === 'Percentage_Used' || key === 'Available_Spare') suffix = '%';
        if (TEMP_KEYS.includes(key) || key === 'Temperature') suffix = '°C';

        // Value tooltip: threshold explanation, with composite decode info if applicable
        const valTipAttr = valTip ? ` data-tip="${valTip}"` : '';

        const tip = ATTR_TIPS[key] || '';
        const tipAttr = tip ? ` data-tip="${tip}"` : '';

        return `<tr>
            <td><span class="attr-name"${tipAttr}>${attrDef.label}</span>${idStr}</td>
            <td class="attr-value ${valClass}"${valTipAttr}>${displayVal}${suffix}</td>
            <td class="attr-delta ${deltaClass}">${deltaStr}</td>
            <td class="spark-cell">${sparkSVG(points, color)}</td>
            <td class="attr-status">${statusIcon}</td>
        </tr>`;
    }

    async function loadHistory(force = false) {
        try {
            const resp = await fetch(`/api/history?days=${deltaRangeDays}`);
            if (resp.ok) historyCache = await resp.json();
        } catch (e) { console.warn('History load failed:', e); }
    }

    async function loadData() {
        try {
            const [diskResp] = await Promise.all([
                fetch('/api/disks'),
                loadHistory(),
            ]);
            if (!diskResp.ok) throw new Error('Failed to load data');
            data = await diskResp.json();
            renderData();
            document.getElementById('error').style.display = 'none';
        } catch (e) {
            document.getElementById('error').textContent = 'Error: ' + e.message;
            document.getElementById('error').style.display = 'block';
        }
    }
    
    // Refresh history periodically
    setInterval(loadHistory, 120000);
    
    function renderData() {
        // Save expanded detail rows and secondary sections before re-render
        const expandedDetails = new Set();
        const expandedSections = new Set();
        document.querySelectorAll('.detail-row.visible').forEach(el => expandedDetails.add(el.id));
        document.querySelectorAll('.secondary-attrs.visible').forEach(el => expandedSections.add(el.id));

        // Update stats
        document.getElementById('statCritical').textContent = data.stats.critical || 0;
        document.getElementById('statWarning').textContent = data.stats.warning || 0;
        document.getElementById('statHealthy').textContent = data.stats.healthy || 0;
        document.getElementById('statTotal').textContent = data.stats.total || 0;
        document.getElementById('statCapacity').textContent = (data.stats.total_capacity_tb || 0) + ' TB';
        document.getElementById('lastUpdate').textContent = 'Updated: ' + new Date().toLocaleTimeString();
        
        // Update host filter dropdown
        const hostFilter = document.getElementById('hostFilter');
        const currentHost = hostFilter.value;
        const hostWrapper = document.getElementById('hostFilterWrapper');
        const hostOptions = hostWrapper.querySelector('.custom-select-options');
        hostOptions.innerHTML = `<div class="custom-select-option${!currentHost ? ' selected' : ''}" data-value="">All Hosts</div>` +
            data.hosts.map(h => `<div class="custom-select-option${h === currentHost ? ' selected' : ''}" data-value="${h}">${h}</div>`).join('');
        
        // Re-attach click handlers for new options
        hostOptions.querySelectorAll('.custom-select-option').forEach(opt => {
            opt.addEventListener('click', (e) => {
                e.stopPropagation();
                selectOption('hostFilterWrapper', opt.dataset.value, opt.textContent, applyFilters);
            });
        });
        
        // Group disks by host
        const byHost = {};
        data.disks.forEach(d => {
            if (!byHost[d.host]) byHost[d.host] = [];
            byHost[d.host].push(d);
        });
        
        // Get host_status from API response
        const hostStatus = data.host_status || {};
        
        // Build map of IP -> full config entry (user@host or just host)
        const hostConfigMap = {};
        (settingsData?.hosts || []).forEach(h => {
            const ip = h.includes('@') ? h.split('@')[1] : h;
            hostConfigMap[ip] = h;
        });
        
        // Helper to get user for a host
        const getHostUser = (host) => {
            const entry = hostConfigMap[host] || host;
            return entry.includes('@') ? entry.split('@')[0] : null;
        };
        
        // Render hosts (all configured hosts, even those without disks)
        let html = '';
        for (const host of data.hosts) {
            const disks = byHost[host] || [];
            const status = hostStatus[host] || {};
            const hasDisks = disks.length > 0;
            const hostUser = getHostUser(host);
            const fullHostEntry = hostConfigMap[host] || host;
            
            // User display (small text if != root)
            const userDisplay = hostUser ? `<span class="host-user">${hostUser}@</span>` : '';
            
            // Inline edit form (hidden by default, replaces host name when editing)
            const hostEditForm = `<div class="host-edit-form" id="hostEdit-${host.replace(/\./g, '-')}" style="display:none;">
                <input type="text" class="host-edit-input host-edit-user" value="${hostUser || ''}" placeholder="user">
                <span class="host-edit-at">@</span>
                <input type="text" class="host-edit-input host-edit-ip" value="${host}">
                <button class="host-edit-confirm" onclick="event.stopPropagation();saveHostEdit('${host}')">✓</button>
                <button class="host-edit-cancel" onclick="event.stopPropagation();hideHostEdit('${host}')">✕</button>
            </div>`;
            
            // Host actions (reload, edit, remove buttons)
            const hostActions = `
                <div class="host-actions">
                    <button class="host-action-btn reload" onclick="event.stopPropagation();rescanHost('${fullHostEntry}')" title="Rescan host">↻</button>
                    <button class="host-action-btn edit" onclick="event.stopPropagation();showHostEdit('${host}')" title="Edit host">✎</button>
                    <button class="host-action-btn delete" onclick="event.stopPropagation();removeHostByName('${fullHostEntry}')" title="Remove host">✕</button>
                </div>`;
            
            if (hasDisks) {
                // Normal host with disks
                const critical = disks.filter(d => d.status === 'critical').length;
                const warning = disks.filter(d => d.status === 'warning').length;
                const capacityTB = (disks.reduce((s, d) => s + (d.capacity_bytes || 0), 0) / 1e12).toFixed(1);
                
                // Find most recent scan timestamp for this host
                let lastScan = '';
                const timestamps = disks.map(d => d.timestamp).filter(Boolean).sort();
                if (timestamps.length > 0) {
                    const ts = timestamps[timestamps.length - 1];
                    const d = new Date(ts.replace(' ', 'T') + 'Z');
                    const now = new Date();
                    const sec = Math.floor((now - d) / 1000);
                    if (sec < 60) lastScan = 'just now';
                    else if (sec < 3600) lastScan = Math.floor(sec / 60) + 'm ago';
                    else if (sec < 86400) lastScan = Math.floor(sec / 3600) + 'h ago';
                    else lastScan = Math.floor(sec / 86400) + 'd ago';
                }
                
                let badge = '<span class="host-badge ok">OK</span>';
                if (critical > 0) badge = `<span class="host-badge critical">${critical} critical</span>`;
                else if (warning > 0) badge = `<span class="host-badge warning">${warning} warning</span>`;
                
                html += `<div class="host-group" data-host="${host}">
                    <div class="host-header" onclick="this.parentElement.classList.toggle('collapsed')">
                        <div>
                            <span class="host-name-display" id="hostDisplay-${host.replace(/\./g, '-')}">${userDisplay}${host}</span>
                            ${hostEditForm}
                            ${badge}
                        </div>
                        <div class="host-stats"><span>${disks.length} drives · ${capacityTB} TB${lastScan ? ` · ${lastScan}` : ''}</span>${hostActions}<span class="host-toggle">▼</span></div>
                    </div>
                    <div class="host-content">
                        <table class="disk-table">
                            <colgroup>
                                <col style="width: 120px">
                                <col style="width: 60px">
                                <col style="width: 240px">
                                <col style="width: 150px">
                                <col style="width: 80px">
                                <col style="width: 80px">
                                <col style="width: 60px">
                                <col style="width: 60px">
                                <col style="width: 60px">
                                <col style="width: 100px">
                                <col>
                            </colgroup>
                            <thead><tr>
                                <th class="sortable" onclick="sortDisks('device')">Device <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('type')">Type <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('model')">Model <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('serial')">Serial <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('size')">Size <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('hours')">Hours <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('temp')">${getTempSymbol()} <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('since')">Since <span class="info-icon" data-tip="Time since first scan of this disk. Shows how long we have historical data.">ⓘ</span> <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('last')">Last <span class="info-icon" data-tip="Time since last scan. Shows how current the data is.">ⓘ</span> <span class="sort-icon">⇅</span></th>
                                <th class="sortable" onclick="sortDisks('status')">Status <span class="sort-icon">⇅</span></th>
                                <th>Issues</th>
                            </tr></thead>
                            <tbody>${sortedDisks(disks).map(d => renderDisk(d)).join('')}</tbody>
                        </table>
                    </div>
                </div>`;
            } else {
                // Host without disks - show status
                const statusLabels = {
                    'pending': { badge: 'pending', text: 'Pending' },
                    'offline': { badge: 'offline', text: 'Offline' },
                    'auth_failed': { badge: 'offline', text: 'Auth failed' },
                    'timeout': { badge: 'offline', text: 'Timeout' },
                    'no_smartctl': { badge: 'warning', text: 'No smartctl' },
                    'no_disks': { badge: 'warning', text: 'No disks' },
                    'error': { badge: 'offline', text: 'Error' },
                };
                const statusInfo = statusLabels[status.status] || { badge: 'offline', text: status.status || 'Unknown' };
                const badge = `<span class="host-badge ${statusInfo.badge}">${statusInfo.text}</span>`;
                
                // Format last attempt time
                let lastAttempt = '';
                if (status.last_attempt) {
                    const d = new Date(status.last_attempt.replace(' ', 'T') + 'Z');
                    const now = new Date();
                    const sec = Math.floor((now - d) / 1000);
                    if (sec < 60) lastAttempt = 'just now';
                    else if (sec < 3600) lastAttempt = Math.floor(sec / 60) + 'm ago';
                    else if (sec < 86400) lastAttempt = Math.floor(sec / 3600) + 'h ago';
                    else lastAttempt = Math.floor(sec / 86400) + 'd ago';
                }
                
                const message = status.message || '';
                const statusText = message + (lastAttempt ? ` · ${lastAttempt}` : '');
                
                html += `<div class="host-group host-error" data-host="${host}">
                    <div class="host-header">
                        <div>
                            <span class="host-name-display" id="hostDisplay-${host.replace(/\./g, '-')}">${userDisplay}${host}</span>
                            ${hostEditForm}
                            ${badge}
                        </div>
                        <div class="host-stats"><span>${statusText || 'Never scanned'}</span>${hostActions}</div>
                    </div>
                </div>`;
            }
        }
        
        document.getElementById('content').innerHTML = html || '<div class="loading">No data available</div>';

        // Restore expanded state
        expandedDetails.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.classList.add('visible');
        });
        expandedSections.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.classList.add('visible');
        });

        applyFilters();
    }
    
    function renderDisk(d) {
        const typeClass = (d.type || '').toLowerCase();
        const statusDot = d.smart_status === 'PASSED' ? 'ok' : 'fail';
        const capacity = d.capacity_bytes >= 1e12 ? (d.capacity_bytes / 1e12).toFixed(1) + 'TB' : (d.capacity_bytes / 1e9).toFixed(0) + 'GB';
        const diskId = d.disk_id || d.serial;
        const eid = diskId.replace(/[\"' ]/g, '_');
        const attrs = d.smart_attributes || {};
        const hist = historyCache[diskId] || {};

        // Hours & temp for main table row
        let hours = parseInt(attrs.Power_On_Hours || attrs.Power_On_Hours_and_Msec || 0);
        const hoursFmt = fmtHours(hours);
        let tempRaw = getTemp(attrs);
        let temp = formatTemp(tempRaw);
        const trend = data.trends[diskId]?.delta > 0 ? '<span class="trend">▲</span>' : '';

        // Calculate data availability (time since first reading)
        const hMeta = hist || {};
        const firstReading = hMeta._first || '';
        const dataAgeMs = firstReading ? (new Date() - new Date(firstReading)) : 0;
        const dataAgeMinutes = dataAgeMs / 60000;
        const dataAgeHours = dataAgeMs / 3600000;
        const dataDays = dataAgeMs / 86400000;
        const dataCoversFilter = dataDays >= deltaRangeDays || deltaRangeDays >= 36500;
        
        // Since cell - show when data started, highlight if filter exceeds data
        let sinceText = '-';
        let sinceClass = '';
        let sinceTooltip = '';
        if (firstReading) {
            // Format: <1h = minutes, <1d = hours, else days
            if (dataDays >= 1) {
                sinceText = Math.floor(dataDays) + 'd';
            } else if (dataAgeHours >= 1) {
                sinceText = Math.floor(dataAgeHours) + 'h';
            } else {
                sinceText = Math.max(1, Math.floor(dataAgeMinutes)) + 'min';
            }
            
            if (!dataCoversFilter) {
                sinceClass = 'since-incomplete';
                const filterStr = deltaRangeDays < 1 ? Math.round(deltaRangeDays * 24) + ' hours' : Math.round(deltaRangeDays) + ' days';
                sinceTooltip = `Only ${sinceText} of data, filter requests ${filterStr}`;
            }
        }

        // Last cell - show time since last scan
        let lastText = '-';
        if (d.timestamp) {
            const lastScan = new Date(d.timestamp.replace(' ', 'T') + 'Z');
            const lastMs = new Date() - lastScan;
            const lastMinutes = lastMs / 60000;
            const lastHours = lastMs / 3600000;
            const lastDays = lastMs / 86400000;
            if (lastDays >= 1) {
                lastText = Math.floor(lastDays) + 'd';
            } else if (lastHours >= 1) {
                lastText = Math.floor(lastHours) + 'h';
            } else {
                lastText = Math.max(1, Math.floor(lastMinutes)) + 'min';
            }
        }

        // Issues - already filtered by backend based on delta
        let issues = '';
        if (d.issues && d.issues.length > 0) {
            for (const issue of d.issues) {
                issues += `<span class="issue ${issue.level}">${issue.text}</span>`;
            }
        }

        // Determine health attrs for this disk type
        const diskType = d.type || 'HDD';
        const isNVMe = diskType === 'NVMe';
        const healthDefs = isNVMe ? HEALTH_ATTRS.nvme : HEALTH_ATTRS.ata;
        const healthKeys = new Set(healthDefs.map(a => a.key));
        TEMP_KEYS.forEach(k => healthKeys.add(k));

        // Sidebar
        const firmware = d.firmware || attrs.Firmware_Version || '';
        const powerCycles = attrs.Power_Cycle_Count || attrs.Power_Cycles || '-';
        const rpm = d.rpm;
        const sectorSize = d.sector_size;
        let sbHtml = '';
        if (d.wwn) sbHtml += `<div class="sidebar-item"><div class="sb-label">WWN</div><div class="sb-value">${d.wwn}</div></div>`;
        if (firmware) sbHtml += `<div class="sidebar-item"><div class="sb-label">Firmware</div><div class="sb-value">${firmware}</div></div>`;
        sbHtml += `<div class="sidebar-item"><div class="sb-label">Power Cycles</div><div class="sb-value">${powerCycles}</div></div>`;
        sbHtml += `<div class="sidebar-item"><div class="sb-label">Power On</div><div class="sb-value">${hours.toLocaleString()}h</div><div class="sb-sub">${fmtDuration(hours)}</div></div>`;
        if (rpm != null && !isNVMe) sbHtml += `<div class="sidebar-item"><div class="sb-label">RPM</div><div class="sb-value">${rpm > 0 ? rpm.toLocaleString() : 'SSD'}</div></div>`;
        if (sectorSize) sbHtml += `<div class="sidebar-item"><div class="sb-label">Sector Size</div><div class="sb-value">${sectorSize}B</div></div>`;

        // History footer info
        const nReadings = hMeta._readings || 0;
        const first = hMeta._first || '';
        const last = hMeta._last || '';
        let spanText = '';
        if (first && last && first !== last) {
            const d1 = new Date(first), d2 = new Date(last);
            const diffDays = Math.round((d2 - d1) / 86400000);
            spanText = diffDays > 0 ? `${nReadings} readings · ${diffDays}d` : `${nReadings} readings`;
        } else if (nReadings) {
            spanText = `${nReadings} readings`;
        }
        if (spanText) sbHtml += `<div class="sidebar-item"><div class="sb-label">History</div><div class="sb-sub">${spanText}</div></div>`;

        // Health attribute rows
        let healthRows = '';
        for (const attrDef of healthDefs) {
            healthRows += renderAttrRow(attrDef, attrs, hist, diskType, !isNVMe, dataCoversFilter, dataAgeMs);
        }

        // Secondary attributes
        const skipKeys = new Set([...healthKeys, ...KEY_METRIC_ATTRS, 'Firmware_Version']);
        const secondaryAttrs = Object.keys(attrs).filter(k => !skipKeys.has(k));
        let secondaryRows = '';
        for (const key of secondaryAttrs) {
            const val = attrs[key];
            const h = hist[key] || null;
            const delta = h ? h.delta : 0;
            const points = h ? h.points : null;
            let deltaStr = '\u2014';
            if (delta > 0) { deltaStr = `+${delta}`; }
            else if (delta < 0) { deltaStr = `${delta}`; }
            // Add period suffix if data doesn't cover filter
            if (delta !== 0 && !dataCoversFilter && dataAgeMs > 0) {
                deltaStr += ` <span class="delta-period">(${formatDuration(dataAgeMs)})</span>`;
            }
            const label = key.replace(/_/g, ' ');
            const tip = ATTR_TIPS[key] || '';
            const tipAttr = tip ? ` data-tip="${tip}"` : '';
            // Format LBA/Data Unit values as human-readable bytes
            let displayVal = val;
            let valTitle = '';
            const numVal = parseInt(val);
            if (LBA_KEYS.has(key) && !isNaN(numVal) && numVal > 0) {
                const bytes = numVal * 512;
                displayVal = fmtBytes(bytes);
                valTitle = ` data-tip="${numVal.toLocaleString()} sectors"`;
            } else if (DATA_UNIT_KEYS.has(key) && !isNaN(numVal) && numVal > 0) {
                const bytes = numVal * 512000;
                displayVal = fmtBytes(bytes);
                valTitle = ` data-tip="${numVal.toLocaleString()} units"`;
            }
            secondaryRows += `<tr>
                <td><span class="attr-name"${tipAttr}>${label}</span></td>
                <td class="attr-value val-ok"${valTitle}>${displayVal}</td>
                <td class="attr-delta">${deltaStr}</td>
                <td class="spark-cell">${points ? sparkSVG(points, '#3b82f6') : ''}</td>
                <td class="attr-status"></td>
            </tr>`;
        }

        const secId = 'sec-' + eid;
        const totalAttrs = healthDefs.length + secondaryAttrs.length;
        
        // Info banner if data doesn't cover filter period
        let infoBanner = '';
        if (!dataCoversFilter && dataAgeMs > 0) {
            const filterStr = deltaRangeDays < 1 ? `${Math.round(deltaRangeDays * 24)} hours` : deltaRangeDays >= 36500 ? 'all time' : `${Math.round(deltaRangeDays)} days`;
            infoBanner = `<div class="data-coverage-info">ℹ Data available: ${sinceText} · Filter: ${filterStr}</div>`;
        }

        return `<tr class="disk-row ${d.status}" data-type="${d.type}" data-status="${d.status}" onclick="toggleDetail('${eid}')">
            <td><span class="device-name">${d.device}</span></td>
            <td><span class="type-badge ${typeClass}">${d.type}</span></td>
            <td>${d.model || '-'}</td>
            <td class="mono muted">${d.serial}</td>
            <td>${capacity}</td>
            <td class="mono">${hoursFmt}${trend}</td>
            <td>${temp !== '-' ? temp + '°' : '-'}</td>
            <td class="${sinceClass}"${sinceTooltip ? ` title="${sinceTooltip}"` : ''}>${sinceText}</td>
            <td>${lastText}</td>
            <td><span class="status-dot ${statusDot}"></span>${d.smart_status}</td>
            <td>${issues || '-'}</td>
        </tr>
        <tr class="detail-row" id="detail-${eid}">
            <td colspan="11">
                <div class="detail-panel">
                    <div class="detail-sidebar">${sbHtml}</div>
                    <div class="detail-main">
                        ${infoBanner}
                        <div class="attr-section-header">
                            <div class="attr-section-title">Health & Endurance</div>
                            ${secondaryAttrs.length > 0 ? `<button class="show-all-btn" id="btn-${secId}" onclick="event.stopPropagation(); let el=document.getElementById('${secId}'); el.classList.toggle('visible'); this.textContent=el.classList.contains('visible')?'Show less':'Show all ${totalAttrs} attributes';">Show all ${totalAttrs} attributes</button>` : ''}
                        </div>
                        <div class="detail-main-body" onclick="event.stopPropagation(); if(event.target.closest('.show-all-btn,.attr-name[data-tip],.attr-value[data-tip]'))return; let btn=document.getElementById('btn-${secId}'); if(btn) btn.click();" style="cursor:pointer;">
                        <table class="attr-table">
                            <thead><tr>
                                <th style="width:38%">Attribute</th>
                                <th class="right" style="width:12%">Value</th>
                                <th class="right" style="width:10%">\u0394</th>
                                <th style="width:25%">Trend</th>
                                <th style="width:5%"></th>
                            </tr></thead>
                            <tbody>${healthRows}</tbody>
                            ${secondaryAttrs.length > 0 ? `<tbody id="${secId}" class="secondary-attrs">${secondaryRows}</tbody>` : ''}
                        </table>
                        </div>
                        ${spanText ? `<div class="detail-footer">First scan: <span>${first}</span> · Last scan: <span>${last}</span></div>` : ''}
                    </div>
                </div>
            </td>
        </tr>`;
    }
    
    function toggleDetail(eid) {
        const target = document.getElementById('detail-' + eid);
        if (!target) return;
        const diskRow = target.previousElementSibling;
        const rowTop = diskRow.getBoundingClientRect().top;
        const isOpen = target.classList.contains('visible');
        document.querySelectorAll('.detail-row.visible').forEach(el => el.classList.remove('visible'));
        if (!isOpen) target.classList.add('visible');
        const newTop = diskRow.getBoundingClientRect().top;
        window.scrollBy(0, newTop - rowTop);
    }
    
    function filterStatus(s) {
        statusFilter = s;
        document.querySelectorAll('.stat').forEach(el => el.classList.remove('active'));
        if (s) event.target.closest('.stat').classList.add('active');
        applyFilters();
    }
    
    function applyFilters() {
        const host = document.getElementById('hostFilter').value;
        const type = document.getElementById('typeFilter').value;
        const search = document.getElementById('search').value.toLowerCase();
        
        document.querySelectorAll('.host-group').forEach(g => {
            if (host && g.dataset.host !== host) { g.style.display = 'none'; return; }
            g.style.display = '';
            let visible = 0;
            g.querySelectorAll('.disk-row').forEach(r => {
                let show = true;
                if (type && r.dataset.type !== type) show = false;
                if (statusFilter && r.dataset.status !== statusFilter) show = false;
                if (search && !r.textContent.toLowerCase().includes(search)) show = false;
                r.style.display = show ? '' : 'none';
                if (!show) document.getElementById('detail-' + r.querySelector('.mono')?.textContent)?.classList.remove('visible');
                if (show) visible++;
            });
            if (!visible && (type || statusFilter || search)) g.style.display = 'none';
        });
    }
    
    // Delta range presets mapping
    const DELTA_PRESETS = {
        '1h': 1/24,
        '24h': 1,
        '7d': 7,
        '30d': 30,
        '90d': 90,
        'all': 36500
    };
    
    function updateDeltaFromDropdown(value) {
        if (DELTA_PRESETS[value] !== undefined) {
            deltaRangeDays = DELTA_PRESETS[value];
        }
        
        // Persist to localStorage
        localStorage.setItem('deltaRangePreset', value);
        
        // Save to server config, then reload all data (backend recalculates issues/status)
        fetch('/api/settings', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({delta_preset: value})
        }).then(() => {
            // Reload data - backend will recalculate issues and status based on new delta
            loadData();
        }).catch(e => console.warn('Failed to save delta range:', e));
    }
    
    function restoreDeltaRange() {
        // Try to get from settingsData (server), fall back to localStorage
        let preset = '7d';
        if (settingsData && settingsData.delta_preset) {
            preset = settingsData.delta_preset;
        } else {
            const saved = localStorage.getItem('deltaRangePreset');
            if (saved) preset = saved;
        }
        
        setDropdownValue('deltaRangeWrapper', preset);
        document.getElementById('deltaRange').value = preset;
        deltaRangeDays = DELTA_PRESETS[preset] || 7;
    }
    
    let currentSort = {field: 'device', asc: true};
    
    function sortDisks(field) {
        // Toggle direction if same field
        if (currentSort.field === field) {
            currentSort.asc = !currentSort.asc;
        } else {
            currentSort.field = field;
            currentSort.asc = true;
        }
        
        // Re-render with new sort
        renderData();
        
        // Update sort icons
        document.querySelectorAll('.sort-icon').forEach(i => i.textContent = '⇅');
        document.querySelectorAll('.sortable').forEach(th => {
            if (th.textContent.toLowerCase().includes(field)) {
                th.querySelector('.sort-icon').textContent = currentSort.asc ? '↑' : '↓';
            }
        });
    }
    
    function getSortValue(disk, field) {
        const attrs = disk.smart_attributes || {};
        switch(field) {
            case 'device':
                return disk.device || '';
            case 'type':
                const typeOrder = {'NVMe': 0, 'SSD': 1, 'HDD': 2, 'Unknown': 3};
                return typeOrder[disk.type] ?? 3;
            case 'model': return disk.model || '';
            case 'serial': return disk.serial || '';
            case 'size': return disk.capacity_bytes || 0;
            case 'hours': return parseInt(attrs.Power_On_Hours || 0);
            case 'temp': return parseInt(attrs.Temperature_Celsius || attrs.Airflow_Temperature_Cel || attrs.Temperature || 0);
            case 'since':
                const diskId = disk.disk_id || disk.serial;
                const hist = historyCache[diskId] || {};
                const first = hist._first || '';
                return first ? new Date(first).getTime() : 0;
            case 'last':
                return disk.timestamp ? new Date(disk.timestamp.replace(' ', 'T') + 'Z').getTime() : 0;
            case 'status': 
                const statusOrder = {'critical': 0, 'warning': 1, 'ok': 2};
                return statusOrder[disk.status] ?? 2;
            default: return 0;
        }
    }
    
    function sortedDisks(disks) {
        return [...disks].sort((a, b) => {
            let va = getSortValue(a, currentSort.field);
            let vb = getSortValue(b, currentSort.field);
            let cmp = 0;
            if (typeof va === 'string') cmp = va.localeCompare(vb);
            else cmp = va - vb;
            return currentSort.asc ? cmp : -cmp;
        });
    }
    
    function refresh() {
        const btn = document.getElementById('refreshBtn');
        btn.disabled = true;
        btn.textContent = '↻ Loading...';
        loadData().finally(() => {
            btn.disabled = false;
            btn.textContent = '↻ Refresh';
        });
    }
    
    function toggleTheme() {
        const isDark = document.body.getAttribute('data-theme') === 'dark';
        document.body.setAttribute('data-theme', isDark ? '' : 'dark');
        document.getElementById('themeBtn').textContent = isDark ? '☀️' : '🌙';
        localStorage.setItem('theme', isDark ? 'light' : 'dark');
    }
    
    // --- Settings Panel ---
    
    function toggleSettings() {
        const overlay = document.getElementById('settingsOverlay');
        if (overlay.style.display === 'none') {
            overlay.style.display = 'flex';
            loadSettings();
        } else {
            overlay.style.display = 'none';
        }
    }
    
    async function loadSettings() {
        try {
            const res = await fetch('/api/settings');
            settingsData = await res.json();
            renderHosts();
            tempUnit = settingsData.temp_unit || 'C';
            document.getElementById('tempUnitSelect').value = tempUnit;
            updatePresetDropdown();
        } catch (e) {
            console.error('Failed to load settings:', e);
        }
    }
    
    function renderHosts() {
        const container = document.getElementById('hostsList');
        const hosts = settingsData.hosts || [];
        const stats = settingsData.host_stats || {};
        if (hosts.length === 0) {
            container.innerHTML = '<div style="font-size:12px;color:#999;padding:4px 0">No hosts configured</div>';
            return;
        }
        container.innerHTML = hosts.map((h, i) => {
            const s = stats[h];
            let info = '<span class="host-status host-new">new</span>';
            if (s) {
                const ago = timeAgo(s.last_seen);
                info = `<span class="host-meta">${s.disk_count} disk${s.disk_count !== 1 ? 's' : ''} · ${ago}</span>`;
            }
            return `<div class="host-row"><span class="host-addr">${h}</span>${info}<button class="host-remove" onclick="removeHost(${i})" title="Remove">✕</button></div>`;
        }).join('');
    }
    
    function timeAgo(ts) {
        const d = new Date(ts.replace(' ', 'T') + 'Z');
        const now = new Date();
        const sec = Math.floor((now - d) / 1000);
        if (sec < 60) return 'just now';
        const min = Math.floor(sec / 60);
        if (min < 60) return min + 'm ago';
        const hr = Math.floor(min / 60);
        if (hr < 24) return hr + 'h ago';
        const days = Math.floor(hr / 24);
        return days + 'd ago';
    }
    
    async function addHost() {
        const input = document.getElementById('hostInput');
        const host = input.value.trim();
        if (!host) return;
        const hosts = [...(settingsData.hosts || [])];
        if (hosts.includes(host)) { input.value = ''; return; }
        hosts.push(host);
        try {
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({hosts})
            });
            const result = await res.json();
            if (result.success) {
                settingsData.hosts = result.hosts || hosts;
                renderHosts();
                input.value = '';
            }
        } catch (e) { console.error('Failed to add host:', e); }
    }
    
    async function removeHost(idx) {
        const hosts = [...(settingsData.hosts || [])];
        hosts.splice(idx, 1);
        try {
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({hosts})
            });
            const result = await res.json();
            if (result.success) {
                settingsData.hosts = result.hosts || hosts;
                renderHosts();
            }
        } catch (e) { console.error('Failed to remove host:', e); }
    }
    
    async function removeHostByName(hostname) {
        const btn = event.target;
        
        // First click: show confirmation state
        if (!btn.classList.contains('confirming')) {
            btn.classList.add('confirming');
            btn.innerHTML = 'Remove?';
            btn.title = 'Click again to confirm';
            
            // Click anywhere else cancels
            const cancelHandler = (e) => {
                if (e.target !== btn) {
                    btn.classList.remove('confirming');
                    btn.innerHTML = '✕';
                    btn.title = 'Remove host';
                    document.removeEventListener('click', cancelHandler, true);
                }
            };
            setTimeout(() => document.addEventListener('click', cancelHandler, true), 0);
            return;
        }
        
        // Second click: actually remove
        btn.classList.remove('confirming');
        btn.innerHTML = '...';
        
        const hosts = (settingsData.hosts || []).filter(h => h !== hostname);
        try {
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({hosts})
            });
            const result = await res.json();
            if (result.success) {
                settingsData.hosts = result.hosts || hosts;
                await loadData();
            }
        } catch (e) { 
            console.error('Failed to remove host:', e);
            btn.innerHTML = '✕';
        }
    }
    
    function showHostEdit(hostIp) {
        const id = hostIp.replace(/\./g, '-');
        const display = document.getElementById('hostDisplay-' + id);
        const form = document.getElementById('hostEdit-' + id);
        if (display && form) {
            display.style.display = 'none';
            form.style.display = 'inline-flex';
            form.querySelector('.host-edit-ip').focus();
        }
    }
    
    function hideHostEdit(hostIp) {
        const id = hostIp.replace(/\./g, '-');
        const display = document.getElementById('hostDisplay-' + id);
        const form = document.getElementById('hostEdit-' + id);
        if (display && form) {
            display.style.display = '';
            form.style.display = 'none';
        }
    }
    
    async function saveHostEdit(oldIp) {
        const id = oldIp.replace(/\./g, '-');
        const form = document.getElementById('hostEdit-' + id);
        if (!form) return;
        
        const newUser = form.querySelector('.host-edit-user').value.trim();
        const newIp = form.querySelector('.host-edit-ip').value.trim();
        
        if (!newIp) {
            hideHostEdit(oldIp);
            return;
        }
        
        // Find current entry in config
        const hosts = [...(settingsData.hosts || [])];
        const idx = hosts.findIndex(h => {
            const ip = h.includes('@') ? h.split('@')[1] : h;
            return ip === oldIp;
        });
        if (idx === -1) return;
        
        // Build new entry
        const newEntry = newUser && newUser !== 'root'
            ? `${newUser}@${newIp}`
            : newIp;
        
        if (newEntry === hosts[idx]) {
            hideHostEdit(oldIp);
            return; // No change
        }
        
        hosts[idx] = newEntry;
        
        try {
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({hosts})
            });
            const result = await res.json();
            if (result.success) {
                settingsData.hosts = result.hosts || hosts;
                await loadData();
            }
        } catch (e) {
            console.error('Failed to update host:', e);
            hideHostEdit(oldIp);
        }
    }
    
    async function rescanHost(hostname) {
        const btn = event.target;
        btn.classList.add('spinning');
        
        try {
            await fetch('/api/collect', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({host: hostname})
            });
            await loadData();
        } catch (e) {
            console.error('Failed to rescan host:', e);
        } finally {
            btn.classList.remove('spinning');
        }
    }
    
    async function refreshAllHosts() {
        const btn = event.target;
        btn.classList.add('spinning');
        
        // Get filtered hosts (respects host filter)
        const hostFilter = document.getElementById('hostFilter').value;
        const hostsToRefresh = hostFilter ? [hostFilter] : (data.hosts || []);
        
        try {
            // Refresh hosts sequentially
            for (const host of hostsToRefresh) {
                await fetch('/api/collect', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({host: host})
                });
            }
            await loadData();
        } catch (e) {
            console.error('Failed to refresh hosts:', e);
        } finally {
            btn.classList.remove('spinning');
        }
    }
    
    function showAddHostInput() {
        document.getElementById('addHostBtn').style.display = 'none';
        document.getElementById('addHostInline').style.display = 'flex';
        document.getElementById('addHostUser').value = '';
        const input = document.getElementById('addHostInput');
        input.value = '';
        input.focus();
    }
    
    function hideAddHostInput() {
        document.getElementById('addHostBtn').style.display = '';
        document.getElementById('addHostInline').style.display = 'none';
        document.getElementById('addHostUser').value = '';
        document.getElementById('addHostInput').value = '';
    }
    
    function handleAddHostKey(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            addHostFromInput();
        } else if (event.key === 'Escape') {
            hideAddHostInput();
        }
    }
    
    async function addHostFromInput() {
        const userInput = document.getElementById('addHostUser');
        const hostInput = document.getElementById('addHostInput');
        const user = userInput.value.trim();
        const ip = hostInput.value.trim();
        if (!ip) return;
        
        // Format: user@host or just host
        const hostEntry = user && user !== 'root' ? `${user}@${ip}` : ip;
        
        const hosts = [...(settingsData.hosts || [])];
        // Check if host already exists (with or without user)
        const existingIp = hosts.find(h => {
            const existingHost = h.includes('@') ? h.split('@')[1] : h;
            return existingHost === ip;
        });
        if (existingIp) { 
            hideAddHostInput();
            return; 
        }
        hosts.push(hostEntry);
        
        // Clear input immediately and show scanning state
        userInput.value = '';
        hostInput.value = '';
        const btn = document.querySelector('.add-host-confirm');
        const originalText = btn.textContent;
        btn.textContent = '...';
        btn.disabled = true;
        
        try {
            // First save the host to config
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({hosts})
            });
            const result = await res.json();
            if (result.success) {
                settingsData.hosts = result.hosts || hosts;
                
                // Now trigger fetch for just this host
                try {
                    await fetch('/api/collect', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({host: hostEntry})
                    });
                } catch (e) {
                    console.warn('Fetch failed:', e);
                }
                
                // Refresh data to show new host
                await loadData();
                hideAddHostInput();
            }
        } catch (e) { 
            console.error('Failed to add host:', e); 
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
        }
    }
    
    async function saveSshUser() {
        const val = document.getElementById('sshUserInput').value.trim();
        if (!val) return;
        try {
            await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ssh_user: val})
            });
        } catch (e) { console.error('Failed to save SSH user:', e); }
    }
    
    async function saveTempUnit() {
        const val = document.getElementById('tempUnitSelect').value;
        tempUnit = val;
        try {
            await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({temp_unit: val})
            });
            renderData(); // Re-render to show new unit
        } catch (e) { console.error('Failed to save temp unit:', e); }
    }
    
    async function setPreset(name) {
        try {
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({threshold_preset: name})
            });
            const result = await res.json();
            if (result.success) {
                // Update settingsData immediately with new preset
                if (settingsData) settingsData.active_preset = name;
                await loadSettings();
                loadData(); // Re-classify all disks with new thresholds
            }
        } catch (e) {
            console.error('Failed to save settings:', e);
        }
    }
    
    async function changePreset(name) {
        // Immediately update UI
        document.getElementById('presetFilter').value = name;
        currentThresholdPreset = name;
        updatePresetButtons();
        
        if (name !== 'custom') {
            await setPreset(name);
        }
    }
    
    function updatePresetDropdown() {
        if (settingsData && settingsData.active_preset) {
            setDropdownValue('presetFilterWrapper', settingsData.active_preset);
            document.getElementById('presetFilter').value = settingsData.active_preset;
        }
    }
    
    // Threshold Editor
    const THRESHOLD_ATTRS = {
        ata: [
            { key: 'Reallocated_Sector_Ct', label: 'Reallocated Sectors', id: 5 },
            { key: 'Reported_Uncorrect', label: 'Reported Uncorrectable', id: 187 },
            { key: 'Command_Timeout', label: 'Command Timeout', id: 188 },
            { key: 'Current_Pending_Sector', label: 'Current Pending Sectors', id: 197 },
            { key: 'Offline_Uncorrectable', label: 'Offline Uncorrectable', id: 198 },
        ],
        nvme: [
            { key: 'Critical_Warning', label: 'Critical Warning' },
            { key: 'Media_and_Data_Integrity_Errors', label: 'Media Errors' },
            { key: 'Available_Spare', label: 'Available Spare', unit: '%', defaultOp: '<' },
            { key: 'Percentage_Used', label: 'Percentage Used', unit: '%' },
            { key: 'Error_Information_Log_Entries', label: 'Error Log Entries' },
            { key: 'Unsafe_Shutdowns', label: 'Unsafe Shutdowns' },
        ]
    };
    
    const PRESET_HINTS = {
        relaxed: 'Relaxed: Higher thresholds for home/lab use. Fewer false positives, alerts only on clear degradation.',
        conservative: 'Conservative: Stricter thresholds for important data. Earlier warnings for proactive replacement.',
        backblaze: 'Backblaze: Based on failure data from 300k+ drives. Balanced sensitivity, industry standard.',
        custom: 'Custom: Your own threshold values. Edit the fields below to customize.'
    };
    
    let thresholdPresets = {};
    let currentThresholdPreset = 'backblaze';
    
    function toggleThresholdEditor() {
        const overlay = document.getElementById('thresholdOverlay');
        if (overlay.classList.contains('visible')) {
            overlay.classList.remove('visible');
        } else {
            overlay.classList.add('visible');
            renderThresholdEditor();
        }
    }
    
    function renderThresholdEditor() {
        if (!settingsData) return;
        
        thresholdPresets = settingsData.all_presets || {};
        currentThresholdPreset = settingsData.active_preset || 'backblaze';
        
        // Get thresholds to display
        const current = settingsData.thresholds || {};
        
        // Render tables
        const isCustom = currentThresholdPreset === 'custom';
        renderThresholdTable('ata', current.ata || {}, isCustom);
        renderThresholdTable('nvme', current.nvme || {}, isCustom);
        
        // Update UI
        updatePresetButtons();
        updatePresetHint();
    }
    
    function renderThresholdTable(type, thresholds, editable) {
        const tbody = document.querySelector(`#${type}Thresholds tbody`);
        const attrs = THRESHOLD_ATTRS[type];
        
        let html = '';
        for (const attr of attrs) {
            const warn = (thresholds.warning || {})[attr.key] || {};
            const crit = (thresholds.critical || {})[attr.key] || {};
            const defaultOp = attr.defaultOp || '>';
            const disabled = editable ? '' : 'disabled';
            
            const warnOp = warn.op || (warn.value !== undefined ? defaultOp : '-');
            const critOp = crit.op || (crit.value !== undefined ? defaultOp : '-');
            
            html += `<tr data-attr="${attr.key}">
                <td>${attr.label}</td>
                <td>
                    <div class="threshold-input">
                        <select data-type="${type}" data-level="warning" data-attr="${attr.key}" data-field="op" onchange="onThresholdChange()" ${disabled}>
                            <option value=">" ${warnOp === '>' ? 'selected' : ''}>&gt;</option>
                            <option value=">=" ${warnOp === '>=' ? 'selected' : ''}>&ge;</option>
                            <option value="<" ${warnOp === '<' ? 'selected' : ''}>&lt;</option>
                            <option value="<=" ${warnOp === '<=' ? 'selected' : ''}>&le;</option>
                            <option value="-" ${warnOp === '-' ? 'selected' : ''}>off</option>
                        </select>
                        <input type="number" min="0" value="${warn.value ?? ''}" 
                            data-type="${type}" data-level="warning" data-attr="${attr.key}" data-field="value"
                            onchange="onThresholdChange()" ${disabled || warnOp === '-' ? 'disabled' : ''}>
                        ${attr.unit ? `<span class="unit">${attr.unit}</span>` : ''}
                    </div>
                </td>
                <td>
                    <div class="threshold-input">
                        <select data-type="${type}" data-level="critical" data-attr="${attr.key}" data-field="op" onchange="onThresholdChange()" ${disabled}>
                            <option value=">" ${critOp === '>' ? 'selected' : ''}>&gt;</option>
                            <option value=">=" ${critOp === '>=' ? 'selected' : ''}>&ge;</option>
                            <option value="<" ${critOp === '<' ? 'selected' : ''}>&lt;</option>
                            <option value="<=" ${critOp === '<=' ? 'selected' : ''}>&le;</option>
                            <option value="-" ${critOp === '-' ? 'selected' : ''}>off</option>
                        </select>
                        <input type="number" min="0" value="${crit.value ?? ''}" 
                            data-type="${type}" data-level="critical" data-attr="${attr.key}" data-field="value"
                            onchange="onThresholdChange()" ${disabled || critOp === '-' ? 'disabled' : ''}>
                        ${attr.unit ? `<span class="unit">${attr.unit}</span>` : ''}
                    </div>
                </td>
            </tr>`;
        }
        tbody.innerHTML = html;
    }
    
    function onThresholdChange() {
        // Enable/disable value input based on op selection
        document.querySelectorAll('.threshold-input select[data-field="op"]:not([disabled])').forEach(sel => {
            const input = sel.parentElement.querySelector('input');
            input.disabled = sel.value === '-';
        });
        
        // Save after short delay
        clearTimeout(window._thresholdSaveTimeout);
        window._thresholdSaveTimeout = setTimeout(saveCustomThresholds, 500);
    }
    
    function updatePresetButtons() {
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === currentThresholdPreset);
        });
        document.getElementById('presetFilter').value = currentThresholdPreset;
    }
    
    function updatePresetHint() {
        document.getElementById('presetHint').textContent = PRESET_HINTS[currentThresholdPreset] || '';
    }
    
    function selectPreset(name) {
        currentThresholdPreset = name;
        document.getElementById('presetFilter').value = name;
        
        const isCustom = name === 'custom';
        
        if (isCustom) {
            // Load current values (or last custom, or copy from current preset)
            const current = settingsData.thresholds || thresholdPresets['backblaze'] || {};
            renderThresholdTable('ata', current.ata || {}, true);
            renderThresholdTable('nvme', current.nvme || {}, true);
        } else {
            // Load preset values (read-only)
            const preset = thresholdPresets[name];
            if (preset) {
                renderThresholdTable('ata', preset.ata || {}, false);
                renderThresholdTable('nvme', preset.nvme || {}, false);
            }
            // Save preset selection
            setPreset(name);
        }
        
        updatePresetButtons();
        updatePresetHint();
    }
    
    async function saveCustomThresholds() {
        // Collect all threshold values from the form
        const thresholds = { ata: { warning: {}, critical: {} }, nvme: { warning: {}, critical: {} } };
        
        document.querySelectorAll('.threshold-input select[data-field="op"]:not([disabled])').forEach(sel => {
            const type = sel.dataset.type;
            const level = sel.dataset.level;
            const attr = sel.dataset.attr;
            const op = sel.value;
            
            if (op !== '-') {
                const input = sel.parentElement.querySelector('input');
                const value = parseInt(input.value) || 0;
                const attrDef = THRESHOLD_ATTRS[type].find(a => a.key === attr);
                
                thresholds[type][level][attr] = {
                    op: op,
                    value: value,
                    display: attrDef?.label?.toLowerCase() || attr.replace(/_/g, ' ').toLowerCase()
                };
                if (attrDef?.id) thresholds[type][level][attr].id = attrDef.id;
            }
        });
        
        try {
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ custom_thresholds: thresholds, threshold_preset: 'custom' })
            });
            const result = await res.json();
            if (result.success) {
                settingsData.thresholds = thresholds;
                settingsData.active_preset = 'custom';
                loadData();
            }
        } catch (e) {
            console.error('Failed to save custom thresholds:', e);
        }
    }
    
    // Init
    if (localStorage.getItem('theme') === 'dark') {
        document.body.setAttribute('data-theme', 'dark');
        document.getElementById('themeBtn').textContent = '🌙';
    }
    initDropdowns();
    // Load settings to get delta range and preset, then load data
    fetch('/api/settings').then(r => r.json()).then(s => {
        settingsData = s;
        restoreDeltaRange();
        updatePresetDropdown();
        loadData();
    }).catch(() => {
        restoreDeltaRange();
        loadData();
    });
    setInterval(loadData, 60000); // Auto-refresh every minute
    </script>
</body>
</html>'''


# ---------------------------------------------------------------------------
# HTTP Request Handler
# ---------------------------------------------------------------------------

class SmartHTTPHandler(BaseHTTPRequestHandler):
    """HTTP request handler for diskmind."""
    
    db_path = './data/smart.db'
    fetch_script = None
    
    def log_message(self, format, *args):
        """Custom log format."""
        print(f"[{self.log_date_time_string()}] {args[0]}")
    
    def send_json(self, data: dict, status: int = 200):
        """Send JSON response."""
        self.send_response(status)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())
    
    def send_html(self, html: str, status: int = 200):
        """Send HTML response."""
        self.send_response(status)
        self.send_header('Content-Type', 'text/html; charset=utf-8')
        self.end_headers()
        self.wfile.write(html.encode())
    
    def do_GET(self):
        """Handle GET requests."""
        parsed = urlparse(self.path)
        path = parsed.path
        
        try:
            if path == '/' or path == '/index.html':
                self.send_html(get_html_template())
            
            elif path == '/api/disks':
                readings = get_current_readings(self.db_path)
                trends = get_trends(self.db_path)
                
                # Get configured hosts - only show these
                config = load_config()
                configured_hosts = config.get('hosts', [])
                
                # Get host status from DB
                host_status = get_host_status(self.db_path)
                
                # Filter readings to only configured hosts
                if configured_hosts:
                    readings = [r for r in readings if r['host'] in configured_hosts]
                
                hosts = list(set(r['host'] for r in readings))
                
                # Get delta setting from config
                delta_preset = config.get('delta_preset', '7d')
                delta_days = DELTA_PRESETS.get(delta_preset, 7)
                
                # Load history for delta calculations
                history_data = get_disk_history(self.db_path, days=delta_days if delta_days < 36500 else 365)
                
                # Classify and parse smart_attributes
                for r in readings:
                    # Parse JSON string to dict first (needed by classify_disk)
                    if r.get('smart_attributes'):
                        try:
                            r['smart_attributes'] = json.loads(r['smart_attributes'])
                        except:
                            r['smart_attributes'] = {}
                    else:
                        r['smart_attributes'] = {}
                    
                    # Get history for this disk
                    disk_id = r.get('disk_id') or r.get('serial')
                    disk_history = history_data.get(disk_id, {})
                    
                    r['status'] = classify_disk(r, disk_history, delta_days)
                    r['issues'] = get_disk_issues(r, disk_history, delta_days)
                
                # Recalculate stats based on new status values
                stats = get_stats(readings)
                
                # Build host_status for all configured hosts
                all_host_status = {}
                for host in configured_hosts:
                    if host in host_status:
                        all_host_status[host] = host_status[host]
                    else:
                        # Host in config but never scanned
                        all_host_status[host] = {
                            'status': 'pending',
                            'message': 'Never scanned',
                            'disk_count': 0,
                            'last_attempt': None,
                            'last_success': None,
                        }
                
                # Also send thresholds to frontend for client-side awareness
                self.send_json({
                    'disks': readings,
                    'hosts': sorted(configured_hosts),
                    'host_status': all_host_status,
                    'stats': stats,
                    'trends': trends,
                    'thresholds': get_thresholds(),
                })
            
            elif path == '/api/hosts':
                hosts = get_hosts(self.db_path)
                self.send_json({'hosts': hosts})
            
            elif path == '/api/stats':
                readings = get_current_readings(self.db_path)
                stats = get_stats(readings)
                self.send_json(stats)
            
            elif path == '/api/settings':
                config = load_config()
                presets = load_all_presets()
                preset_name = config.get('threshold_preset', DEFAULT_PRESET)
                
                # Build preset summary for frontend
                preset_list = []
                for name, preset in presets.items():
                    preset_list.append({
                        'name': name,
                        'description': preset.get('_description', ''),
                        'active': name == preset_name,
                    })
                
                self.send_json({
                    'active_preset': preset_name,
                    'presets': preset_list,
                    'all_presets': presets,  # Full preset data for threshold editor
                    'thresholds': get_thresholds(),
                    'hosts': config.get('hosts', []),
                    'ssh_user': config.get('ssh', {}).get('user', 'root'),
                    'temp_unit': config.get('temp_unit', 'C'),
                    'host_stats': get_host_stats(self.db_path),
                    'delta_preset': config.get('delta_preset', '7d'),
                })

            elif path == '/api/history':
                params = parse_qs(parsed.query)
                disk_id = params.get('disk_id', [None])[0]
                days = float(params.get('days', [30])[0])
                history = get_disk_history(self.db_path, disk_id, days)
                self.send_json(history)
            
            else:
                self.send_response(404)
                self.end_headers()
                self.wfile.write(b'Not Found')
        
        except Exception as e:
            self.send_json({'error': str(e)}, 500)
    
    def do_POST(self):
        """Handle POST requests."""
        parsed = urlparse(self.path)
        path = parsed.path
        
        try:
            # Read request body
            content_length = int(self.headers.get('Content-Length', 0))
            body = self.rfile.read(content_length) if content_length > 0 else b''
            
            if path == '/api/settings':
                try:
                    data = json.loads(body) if body else {}
                except json.JSONDecodeError:
                    self.send_json({'error': 'Invalid JSON'}, 400)
                    return
                
                result = {}
                
                # Handle custom thresholds
                custom_thresholds = data.get('custom_thresholds')
                if custom_thresholds:
                    # Save custom thresholds to config
                    save_custom_thresholds(custom_thresholds)
                    invalidate_threshold_cache()
                    result['thresholds'] = custom_thresholds
                
                # Handle threshold preset change
                preset_name = data.get('threshold_preset')
                if preset_name:
                    if preset_name == 'custom':
                        # Just mark as custom, thresholds already saved above
                        save_config_value('threshold_preset', 'custom')
                        result['active_preset'] = 'custom'
                    else:
                        presets = load_all_presets()
                        if preset_name not in presets:
                            self.send_json({'error': f'Unknown preset: {preset_name}'}, 400)
                            return
                        save_config_value('threshold_preset', preset_name)
                        invalidate_threshold_cache()
                        result['active_preset'] = preset_name
                
                # Handle hosts change
                hosts = data.get('hosts')
                if hosts is not None:
                    # Validate: list of non-empty strings
                    hosts = [h.strip() for h in hosts if h.strip()]
                    save_config_list('hosts', hosts)
                    result['hosts'] = hosts
                
                # Handle ssh_user change
                ssh_user = data.get('ssh_user')
                if ssh_user is not None:
                    save_config_subkey('ssh', 'user', ssh_user.strip())
                    result['ssh_user'] = ssh_user.strip()
                
                # Handle temp_unit change
                temp_unit = data.get('temp_unit')
                if temp_unit is not None and temp_unit in ('C', 'F'):
                    save_config_value('temp_unit', temp_unit)
                    result['temp_unit'] = temp_unit
                
                # Handle delta preset change
                delta_preset = data.get('delta_preset')
                if delta_preset is not None:
                    save_config_value('delta_preset', delta_preset)
                    result['delta_preset'] = delta_preset
                
                result['success'] = True
                self.send_json(result)
            
            elif path == '/api/collect':
                # Trigger data collection
                if self.fetch_script:
                    # Check for specific host in request body
                    try:
                        req_data = json.loads(body) if body else {}
                    except json.JSONDecodeError:
                        req_data = {}
                    
                    cmd = [sys.executable, self.fetch_script]
                    # If specific host requested, only fetch that one
                    if req_data.get('host'):
                        cmd.extend(['--hosts', req_data['host']])
                    
                    result = subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True,
                        timeout=300
                    )
                    self.send_json({
                        'success': result.returncode == 0,
                        'output': result.stdout,
                        'error': result.stderr,
                    })
                else:
                    self.send_json({'error': 'Collect script not configured'}, 500)
            else:
                self.send_response(404)
                self.end_headers()
        
        except Exception as e:
            self.send_json({'error': str(e)}, 500)


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description='diskmind Web Server')
    parser.add_argument('-p', '--port', type=int, default=8080, help='Port (default: 8080)')
    parser.add_argument('--host', default='0.0.0.0', help='Host (default: 0.0.0.0)')
    parser.add_argument('--db', default='./data/smart.db', help='Database path')
    parser.add_argument('-c', '--config', default='config/config.yaml', help='Config file')
    parser.add_argument('-o', '--output', help='Generate static HTML file and exit')
    
    args = parser.parse_args()
    
    # Load config
    if HAS_YAML and os.path.exists(args.config):
        with open(args.config) as f:
            config = yaml.safe_load(f)
        args.db = config.get('database', {}).get('path', args.db)
    
    # Check database
    if not os.path.exists(args.db):
        print(f"Error: Database not found: {args.db}", file=sys.stderr)
        print("Run diskmind-fetch first to gather data.", file=sys.stderr)
        sys.exit(1)
    
    # Static HTML export mode
    if args.output:
        print(f"Generating static report...")
        print(f"Database: {args.db}")
        
        readings = get_current_readings(args.db)
        trends = get_trends(args.db)
        stats = get_stats(readings)
        hosts = sorted(set(r['host'] for r in readings))
        
        for r in readings:
            r['status'] = classify_disk(r)
        
        html = generate_static_html(readings, trends, stats, hosts)
        
        Path(args.output).parent.mkdir(parents=True, exist_ok=True)
        with open(args.output, 'w') as f:
            f.write(html)
        
        print(f"Output: {args.output}")
        print(f"Disks: {stats['total']} ({stats['critical']} critical, {stats['warning']} warning)")
        return
    
    # Set handler config
    SmartHTTPHandler.db_path = args.db
    SmartHTTPHandler.fetch_script = str(Path(__file__).parent / 'diskmind-fetch')
    
    # Start server
    server = HTTPServer((args.host, args.port), SmartHTTPHandler)
    
    print(f"diskmind Web Server")
    print(f"=" * 40)
    print(f"Database: {args.db}")
    print(f"URL: http://{args.host}:{args.port}")
    print(f"")
    print(f"Press Ctrl+C to stop")
    print()
    
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down...")
        server.shutdown()


if __name__ == '__main__':
    main()
