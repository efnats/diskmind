#!/bin/bash
# diskmind-scan - Node Agent
# Outputs SMART data as CSV to stdout

# CSV Header
echo "wwn,serial,device,type,model,capacity_bytes,firmware,rpm,sector_size,smart_status,smart_attributes"

# Find all block devices (whole disks only, not partitions)
for dev in /dev/sd[a-z] /dev/sd[a-z][a-z] /dev/nvme[0-9]n1 /dev/nvme[0-9][0-9]n1; do
    [ -b "$dev" ] || continue
    
    # Get SMART info (skip if no access)
    info=$(smartctl -i "$dev" 2>&1) || continue
    echo "$info" | grep -qi "permission denied\|unable to detect\|not supported" && continue
    
    attrs=$(smartctl -A "$dev" 2>/dev/null) || true
    health=$(smartctl -H "$dev" 2>/dev/null) || true
    
    # Extract basic info
    serial=$(echo "$info" | grep -i "serial number" | cut -d: -f2 | xargs)
    model=$(echo "$info" | grep -iE "device model|model number|product" | head -1 | cut -d: -f2 | xargs | tr ',' ' ')
    
    # Extract WWN (World Wide Name) - globally unique disk identifier
    # ATA/SATA: "LU WWN Device Id: 5 0014ee 156557a28" → "50014ee156557a28"
    # NVMe: "IEEE EUI-64: 002538 ..." or "NGUID: ..."
    wwn=""
    wwn_raw=$(echo "$info" | grep -iE "LU WWN Device Id|IEEE EUI-64|NGUID" | head -1 | cut -d: -f2-)
    if [ -n "$wwn_raw" ]; then
        wwn=$(echo "$wwn_raw" | tr -d ' ' | tr '[:upper:]' '[:lower:]')
    fi
    
    # Capacity - try multiple patterns (SATA: "User Capacity", NVMe: "Total NVM Capacity" or "Namespace 1 Size")
    capacity=$(echo "$info" | grep -iE "user capacity|total nvm capacity|namespace 1 size" | head -1 | grep -oE '[0-9,]+' | head -1 | tr -d ',')
    
    # Firmware version
    firmware=$(echo "$info" | grep -iE "firmware version" | head -1 | cut -d: -f2 | xargs)
    
    # Rotation rate: extract RPM number, or "0" for SSD/NVMe
    rpm_raw=$(echo "$info" | grep -iE "rotation rate" | head -1 | cut -d: -f2 | xargs)
    if echo "$rpm_raw" | grep -qiE "solid state|not rotational"; then
        rpm="0"
    else
        rpm=$(echo "$rpm_raw" | grep -oE '[0-9]+' | head -1)
        [ -z "$rpm" ] && rpm=""
    fi
    
    # Sector size: logical bytes (e.g. "512 bytes logical/physical" → "512")
    sector_size=$(echo "$info" | grep -iE "sector size" | head -1 | grep -oE '[0-9]+' | head -1)
    [ -z "$sector_size" ] && sector_size=""
    
    # Detect type
    if echo "$info" | grep -qi "nvme"; then
        type="NVMe"
    elif echo "$info" | grep -qi "rotation rate.*rpm"; then
        type="HDD"
    elif echo "$info" | grep -qi "solid state\|ssd"; then
        type="SSD"
    elif [ -f "/sys/block/$(basename $dev)/queue/rotational" ]; then
        [ "$(cat /sys/block/$(basename $dev)/queue/rotational)" = "1" ] && type="HDD" || type="SSD"
    else
        type="Unknown"
    fi
    
    # SMART status
    if echo "$health" | grep -qi "passed"; then
        status="PASSED"
    elif echo "$health" | grep -qi "failed"; then
        status="FAILED"
    else
        status="N/A"
    fi
    
    # Fallback serial
    [ -z "$serial" ] && serial="$(hostname):$(basename $dev)"
    
    # Build JSON with ALL SMART attributes
    json="{"
    first=true
    
    if [ "$type" = "NVMe" ]; then
        # NVMe: key:value format
        while IFS= read -r line; do
            if echo "$line" | grep -qE '^\s*[A-Za-z].*:'; then
                key=$(echo "$line" | cut -d: -f1 | xargs | tr ' ' '_')
                val=$(echo "$line" | cut -d: -f2- | xargs)
                [ -z "$key" ] && continue
                # Extract just the number (remove commas, units like "Celsius", brackets)
                num=$(echo "$val" | tr -d ',' | grep -oE '^[0-9]+' | head -1)
                # Use number if found, otherwise use cleaned string
                if [ -n "$num" ]; then
                    val="$num"
                else
                    val=$(echo "$val" | tr '"' "'")
                fi
                $first && first=false || json="$json,"
                json="$json\"$key\":\"$val\""
            fi
        done <<< "$attrs"
    else
        # ATA: table format - get RAW_VALUE (column 10)
        while IFS= read -r line; do
            if echo "$line" | grep -qE '^\s*[0-9]+\s+\S+\s+0x'; then
                name=$(echo "$line" | awk '{print $2}')
                # Get raw value - extract just the number
                raw=$(echo "$line" | awk '{print $10}' | grep -oE '^[0-9]+' | head -1)
                [ -z "$raw" ] && raw="0"
                $first && first=false || json="$json,"
                json="$json\"$name\":\"$raw\""
            fi
        done <<< "$attrs"
    fi
    json="$json}"
    
    # Escape for CSV
    json_escaped=$(echo "$json" | sed 's/"/""/g')
    
    # Output CSV row
    printf '%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,"%s"\n' \
        "$wwn" "$serial" "$dev" "$type" "$model" \
        "${capacity:-0}" "$firmware" "${rpm}" "${sector_size}" \
        "$status" "$json_escaped"
done
